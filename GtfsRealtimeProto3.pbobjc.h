// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: gtfs-realtime.proto3

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers.h>
#else
 #import "GPBProtocolBuffers.h"
#endif

#if GOOGLE_PROTOBUF_OBJC_VERSION < 30002
#error This file was generated by a newer version of protoc which is incompatible with your Protocol Buffer library sources.
#endif
#if 30002 < GOOGLE_PROTOBUF_OBJC_MIN_SUPPORTED_VERSION
#error This file was generated by an older version of protoc which is incompatible with your Protocol Buffer library sources.
#endif

// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

CF_EXTERN_C_BEGIN

@class Alert;
@class EntitySelector;
@class FeedEntity;
@class FeedHeader;
@class Position;
@class TimeRange;
@class TranslatedString;
@class TranslatedString_Translation;
@class TripDescriptor;
@class TripUpdate;
@class TripUpdate_StopTimeEvent;
@class TripUpdate_StopTimeUpdate;
@class VehicleDescriptor;
@class VehiclePosition;

NS_ASSUME_NONNULL_BEGIN

#pragma mark - Enum FeedHeader_Incrementality

/**
 * Determines whether the current fetch is incremental.  Currently,
 * DIFFERENTIAL mode is unsupported and behavior is unspecified for feeds
 * that use this mode.  There are discussions on the GTFS-realtime mailing
 * list around fully specifying the behavior of DIFFERENTIAL mode and the
 * documentation will be updated when those discussions are finalized.
 **/
typedef GPB_ENUM(FeedHeader_Incrementality) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  FeedHeader_Incrementality_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  FeedHeader_Incrementality_FullDataset = 0,
  FeedHeader_Incrementality_Differential = 1,
};

GPBEnumDescriptor *FeedHeader_Incrementality_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL FeedHeader_Incrementality_IsValidValue(int32_t value);

#pragma mark - Enum TripUpdate_StopTimeUpdate_ScheduleRelationship

/** The relation between this StopTime and the static schedule. */
typedef GPB_ENUM(TripUpdate_StopTimeUpdate_ScheduleRelationship) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  TripUpdate_StopTimeUpdate_ScheduleRelationship_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  /**
   * The vehicle is proceeding in accordance with its static schedule of
   * stops, although not necessarily according to the times of the schedule.
   * At least one of arrival and departure must be provided. If the schedule
   * for this stop contains both arrival and departure times then so must
   * this update.
   **/
  TripUpdate_StopTimeUpdate_ScheduleRelationship_Scheduled = 0,

  /**
   * The stop is skipped, i.e., the vehicle will not stop at this stop.
   * Arrival and departure are // optional.
   **/
  TripUpdate_StopTimeUpdate_ScheduleRelationship_Skipped = 1,

  /**
   * No data is given for this stop. The main intention for this value is to
   * give the predictions only for part of a trip, i.e., if the last update
   * for a trip has a NO_DATA specifier, then StopTimes for the rest of the
   * stops in the trip are considered to be unspecified as well.
   * Neither arrival nor departure should be supplied.
   **/
  TripUpdate_StopTimeUpdate_ScheduleRelationship_NoData = 2,
};

GPBEnumDescriptor *TripUpdate_StopTimeUpdate_ScheduleRelationship_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL TripUpdate_StopTimeUpdate_ScheduleRelationship_IsValidValue(int32_t value);

#pragma mark - Enum VehiclePosition_VehicleStopStatus

typedef GPB_ENUM(VehiclePosition_VehicleStopStatus) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  VehiclePosition_VehicleStopStatus_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  /**
   * The vehicle is just about to arrive at the stop (on a stop
   * display, the vehicle symbol typically flashes).
   **/
  VehiclePosition_VehicleStopStatus_IncomingAt = 0,

  /** The vehicle is standing at the stop. */
  VehiclePosition_VehicleStopStatus_StoppedAt = 1,

  /** The vehicle has departed and is in transit to the next stop. */
  VehiclePosition_VehicleStopStatus_InTransitTo = 2,
};

GPBEnumDescriptor *VehiclePosition_VehicleStopStatus_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL VehiclePosition_VehicleStopStatus_IsValidValue(int32_t value);

#pragma mark - Enum VehiclePosition_CongestionLevel

/** Congestion level that is affecting this vehicle. */
typedef GPB_ENUM(VehiclePosition_CongestionLevel) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  VehiclePosition_CongestionLevel_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  VehiclePosition_CongestionLevel_UnknownCongestionLevel = 0,
  VehiclePosition_CongestionLevel_RunningSmoothly = 1,
  VehiclePosition_CongestionLevel_StopAndGo = 2,
  VehiclePosition_CongestionLevel_Congestion = 3,

  /** People leaving their cars. */
  VehiclePosition_CongestionLevel_SevereCongestion = 4,
};

GPBEnumDescriptor *VehiclePosition_CongestionLevel_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL VehiclePosition_CongestionLevel_IsValidValue(int32_t value);

#pragma mark - Enum VehiclePosition_OccupancyStatus

/**
 * The degree of passenger occupancy of the vehicle. This field is still
 * experimental, and subject to change. It may be formally adopted in the
 * future.
 **/
typedef GPB_ENUM(VehiclePosition_OccupancyStatus) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  VehiclePosition_OccupancyStatus_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  /**
   * The vehicle is considered empty by most measures, and has few or no
   * passengers onboard, but is still accepting passengers.
   **/
  VehiclePosition_OccupancyStatus_Empty = 0,

  /**
   * The vehicle has a relatively large percentage of seats available.
   * What percentage of free seats out of the total seats available is to be
   * considered large enough to fall into this category is determined at the
   * discretion of the producer.
   **/
  VehiclePosition_OccupancyStatus_ManySeatsAvailable = 1,

  /**
   * The vehicle has a relatively small percentage of seats available.
   * What percentage of free seats out of the total seats available is to be
   * considered small enough to fall into this category is determined at the
   * discretion of the feed producer.
   **/
  VehiclePosition_OccupancyStatus_FewSeatsAvailable = 2,

  /** The vehicle can currently accommodate only standing passengers. */
  VehiclePosition_OccupancyStatus_StandingRoomOnly = 3,

  /**
   * The vehicle can currently accommodate only standing passengers
   * and has limited space for them.
   **/
  VehiclePosition_OccupancyStatus_CrushedStandingRoomOnly = 4,

  /**
   * The vehicle is considered full by most measures, but may still be
   * allowing passengers to board.
   **/
  VehiclePosition_OccupancyStatus_Full = 5,

  /** The vehicle is not accepting additional passengers. */
  VehiclePosition_OccupancyStatus_NotAcceptingPassengers = 6,
};

GPBEnumDescriptor *VehiclePosition_OccupancyStatus_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL VehiclePosition_OccupancyStatus_IsValidValue(int32_t value);

#pragma mark - Enum Alert_Cause

/** Cause of this alert. */
typedef GPB_ENUM(Alert_Cause) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  Alert_Cause_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  Alert_Cause_Proto3DefaultCause = 0,
  Alert_Cause_UnknownCause = 1,

  /** Not machine-representable. */
  Alert_Cause_OtherCause = 2,
  Alert_Cause_TechnicalProblem = 3,

  /** Public transit agency employees stopped working. */
  Alert_Cause_Strike = 4,

  /** People are blocking the streets. */
  Alert_Cause_Demonstration = 5,
  Alert_Cause_Accident = 6,
  Alert_Cause_Holiday = 7,
  Alert_Cause_Weather = 8,
  Alert_Cause_Maintenance = 9,
  Alert_Cause_Construction = 10,
  Alert_Cause_PoliceActivity = 11,
  Alert_Cause_MedicalEmergency = 12,
};

GPBEnumDescriptor *Alert_Cause_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL Alert_Cause_IsValidValue(int32_t value);

#pragma mark - Enum Alert_Effect

/** What is the effect of this problem on the affected entity. */
typedef GPB_ENUM(Alert_Effect) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  Alert_Effect_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  Alert_Effect_Proto3DefaultEffect = 0,
  Alert_Effect_NoService = 1,
  Alert_Effect_ReducedService = 2,

  /**
   * We don't care about INsignificant delays: they are hard to detect, have
   * little impact on the user, and would clutter the results as they are too
   * frequent.
   **/
  Alert_Effect_SignificantDelays = 3,
  Alert_Effect_Detour = 4,
  Alert_Effect_AdditionalService = 5,
  Alert_Effect_ModifiedService = 6,
  Alert_Effect_OtherEffect = 7,
  Alert_Effect_UnknownEffect = 8,
  Alert_Effect_StopMoved = 9,
};

GPBEnumDescriptor *Alert_Effect_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL Alert_Effect_IsValidValue(int32_t value);

#pragma mark - Enum TripDescriptor_ScheduleRelationship

/**
 * The relation between this trip and the static schedule. If a trip is done
 * in accordance with temporary schedule, not reflected in GTFS, then it
 * shouldn't be marked as SCHEDULED, but likely as ADDED.
 **/
typedef GPB_ENUM(TripDescriptor_ScheduleRelationship) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  TripDescriptor_ScheduleRelationship_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  /**
   * Trip that is running in accordance with its GTFS schedule, or is close
   * enough to the scheduled trip to be associated with it.
   **/
  TripDescriptor_ScheduleRelationship_Scheduled = 0,

  /**
   * An extra trip that was added in addition to a running schedule, for
   * example, to replace a broken vehicle or to respond to sudden passenger
   * load.
   **/
  TripDescriptor_ScheduleRelationship_Added = 1,

  /**
   * A trip that is running with no schedule associated to it, for example, if
   * there is no schedule at all.
   **/
  TripDescriptor_ScheduleRelationship_Unscheduled = 2,

  /** A trip that existed in the schedule but was removed. */
  TripDescriptor_ScheduleRelationship_Canceled = 3,
};

GPBEnumDescriptor *TripDescriptor_ScheduleRelationship_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL TripDescriptor_ScheduleRelationship_IsValidValue(int32_t value);

#pragma mark - GtfsRealtimeProto3Root

/**
 * Exposes the extension registry for this file.
 *
 * The base class provides:
 * @code
 *   + (GPBExtensionRegistry *)extensionRegistry;
 * @endcode
 * which is a @c GPBExtensionRegistry that includes all the extensions defined by
 * this file and all files that it depends on.
 **/
@interface GtfsRealtimeProto3Root : GPBRootObject
@end

#pragma mark - FeedMessage

typedef GPB_ENUM(FeedMessage_FieldNumber) {
  FeedMessage_FieldNumber_Header = 1,
  FeedMessage_FieldNumber_EntityArray = 2,
};

/**
 * The contents of a feed message.
 * A feed is a continuous stream of feed messages. Each message in the stream is
 * obtained as a response to an appropriate HTTP GET request.
 * A realtime feed is always defined with relation to an existing GTFS feed.
 * All the entity ids are resolved with respect to the GTFS feed.
 *
 * A feed depends on some external configuration:
 * - The corresponding GTFS feed.
 * - Feed application (updates, positions or alerts). A feed should contain only
 *   items of one specified application; all the other entities will be ignored.
 * - Polling frequency
 **/
@interface FeedMessage : GPBMessage

/**
 * Metadata about this feed and feed message.
 * required FeedHeader header = 1;
 **/
@property(nonatomic, readwrite, strong, null_resettable) FeedHeader *header;
/** Test to see if @c header has been set. */
@property(nonatomic, readwrite) BOOL hasHeader;

/** Contents of the feed. */
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<FeedEntity*> *entityArray;
/** The number of items in @c entityArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger entityArray_Count;

@end

#pragma mark - FeedHeader

typedef GPB_ENUM(FeedHeader_FieldNumber) {
  FeedHeader_FieldNumber_GtfsRealtimeVersion = 1,
  FeedHeader_FieldNumber_Incrementality = 2,
  FeedHeader_FieldNumber_Timestamp = 3,
};

/**
 * Metadata about a feed, included in feed messages.
 **/
@interface FeedHeader : GPBMessage

/**
 * Version of the feed specification.
 * The current version is 1.0.
 * required string gtfs_realtime_version = 1;
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *gtfsRealtimeVersion;

/** optional Incrementality incrementality = 2 [default = FULL_DATASET]; */
@property(nonatomic, readwrite) FeedHeader_Incrementality incrementality;

/**
 * This timestamp identifies the moment when the content of this feed has been
 * created (in server time). In POSIX time (i.e., number of seconds since
 * January 1st 1970 00:00:00 UTC).
 * optional uint64 timestamp = 3;
 **/
@property(nonatomic, readwrite) uint64_t timestamp;

@end

/**
 * Fetches the raw value of a @c FeedHeader's @c incrementality property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t FeedHeader_Incrementality_RawValue(FeedHeader *message);
/**
 * Sets the raw value of an @c FeedHeader's @c incrementality property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetFeedHeader_Incrementality_RawValue(FeedHeader *message, int32_t value);

#pragma mark - FeedEntity

typedef GPB_ENUM(FeedEntity_FieldNumber) {
  FeedEntity_FieldNumber_Id_p = 1,
  FeedEntity_FieldNumber_IsDeleted = 2,
  FeedEntity_FieldNumber_TripUpdate = 3,
  FeedEntity_FieldNumber_Vehicle = 4,
  FeedEntity_FieldNumber_Alert = 5,
};

/**
 * A definition (or update) of an entity in the transit feed.
 **/
@interface FeedEntity : GPBMessage

/**
 * The ids are used only to provide incrementality support. The id should be
 * unique within a FeedMessage. Consequent FeedMessages may contain
 * FeedEntities with the same id. In case of a DIFFERENTIAL update the new
 * FeedEntity with some id will replace the old FeedEntity with the same id
 * (or delete it - see is_deleted below).
 * The actual GTFS entities (e.g. stations, routes, trips) referenced by the
 * feed must be specified by explicit selectors (see EntitySelector below for
 * more info).
 * required string id = 1;
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *id_p;

/**
 * Whether this entity is to be deleted. Relevant only for incremental
 * fetches.
 * optional bool is_deleted = 2 [default = false];
 **/
@property(nonatomic, readwrite) BOOL isDeleted;

/**
 * Data about the entity itself. Exactly one of the following fields must be
 * present (unless the entity is being deleted).
 * optional TripUpdate trip_update = 3;
 **/
@property(nonatomic, readwrite, strong, null_resettable) TripUpdate *tripUpdate;
/** Test to see if @c tripUpdate has been set. */
@property(nonatomic, readwrite) BOOL hasTripUpdate;

/** optional VehiclePosition vehicle = 4; */
@property(nonatomic, readwrite, strong, null_resettable) VehiclePosition *vehicle;
/** Test to see if @c vehicle has been set. */
@property(nonatomic, readwrite) BOOL hasVehicle;

/** optional Alert alert = 5; */
@property(nonatomic, readwrite, strong, null_resettable) Alert *alert;
/** Test to see if @c alert has been set. */
@property(nonatomic, readwrite) BOOL hasAlert;

@end

#pragma mark - TripUpdate

typedef GPB_ENUM(TripUpdate_FieldNumber) {
  TripUpdate_FieldNumber_Trip = 1,
  TripUpdate_FieldNumber_StopTimeUpdateArray = 2,
  TripUpdate_FieldNumber_Vehicle = 3,
  TripUpdate_FieldNumber_Timestamp = 4,
  TripUpdate_FieldNumber_Delay = 5,
};

/**
 * Realtime update of the progress of a vehicle along a trip.
 * Depending on the value of ScheduleRelationship, a TripUpdate can specify:
 * - A trip that proceeds along the schedule.
 * - A trip that proceeds along a route but has no fixed schedule.
 * - A trip that have been added or removed with regard to schedule.
 *
 * The updates can be for future, predicted arrival/departure events, or for
 * past events that already occurred.
 * Normally, updates should get more precise and more certain (see
 * uncertainty below) as the events gets closer to current time.
 * Even if that is not possible, the information for past events should be
 * precise and certain. In particular, if an update points to time in the past
 * but its update's uncertainty is not 0, the client should conclude that the
 * update is a (wrong) prediction and that the trip has not completed yet.
 *
 * Note that the update can describe a trip that is already completed.
 * To this end, it is enough to provide an update for the last stop of the trip.
 * If the time of that is in the past, the client will conclude from that that
 * the whole trip is in the past (it is possible, although inconsequential, to
 * also provide updates for preceding stops).
 * This option is most relevant for a trip that has completed ahead of schedule,
 * but according to the schedule, the trip is still proceeding at the current
 * time. Removing the updates for this trip could make the client assume
 * that the trip is still proceeding.
 * Note that the feed provider is allowed, but not required, to purge past
 * updates - this is one case where this would be practically useful.
 **/
@interface TripUpdate : GPBMessage

/**
 * The Trip that this message applies to. There can be at most one
 * TripUpdate entity for each actual trip instance.
 * If there is none, that means there is no prediction information available.
 * It does *not* mean that the trip is progressing according to schedule.
 * required TripDescriptor trip = 1;
 **/
@property(nonatomic, readwrite, strong, null_resettable) TripDescriptor *trip;
/** Test to see if @c trip has been set. */
@property(nonatomic, readwrite) BOOL hasTrip;

/**
 * Additional information on the vehicle that is serving this trip.
 * optional VehicleDescriptor vehicle = 3;
 **/
@property(nonatomic, readwrite, strong, null_resettable) VehicleDescriptor *vehicle;
/** Test to see if @c vehicle has been set. */
@property(nonatomic, readwrite) BOOL hasVehicle;

/**
 * Updates to StopTimes for the trip (both future, i.e., predictions, and in
 * some cases, past ones, i.e., those that already happened).
 * The updates must be sorted by stop_sequence, and apply for all the
 * following stops of the trip up to the next specified one.
 *
 * Example 1:
 * For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
 * delay of 0 for stop_sequence of the current stop means that the trip is
 * exactly on time.
 *
 * Example 2:
 * For the same trip instance, 3 StopTimeUpdates are provided:
 * - delay of 5 min for stop_sequence 3
 * - delay of 1 min for stop_sequence 8
 * - delay of unspecified duration for stop_sequence 10
 * This will be interpreted as:
 * - stop_sequences 3,4,5,6,7 have delay of 5 min.
 * - stop_sequences 8,9 have delay of 1 min.
 * - stop_sequences 10,... have unknown delay.
 **/
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<TripUpdate_StopTimeUpdate*> *stopTimeUpdateArray;
/** The number of items in @c stopTimeUpdateArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger stopTimeUpdateArray_Count;

/**
 * Moment at which the vehicle's real-time progress was measured. In POSIX
 * time (i.e., the number of seconds since January 1st 1970 00:00:00 UTC).
 * optional uint64 timestamp = 4;
 **/
@property(nonatomic, readwrite) uint64_t timestamp;

/**
 * The current schedule deviation for the trip.  Delay should only be
 * specified when the prediction is given relative to some existing schedule
 * in GTFS.
 *
 * Delay (in seconds) can be positive (meaning that the vehicle is late) or
 * negative (meaning that the vehicle is ahead of schedule). Delay of 0
 * means that the vehicle is exactly on time.
 *
 * Delay information in StopTimeUpdates take precedent of trip-level delay
 * information, such that trip-level delay is only propagated until the next
 * stop along the trip with a StopTimeUpdate delay value specified.
 *
 * Feed providers are strongly encouraged to provide a TripUpdate.timestamp
 * value indicating when the delay value was last updated, in order to
 * evaluate the freshness of the data.
 *
 * NOTE: This field is still experimental, and subject to change. It may be
 * formally adopted in the future.
 * optional int32 delay = 5;
 **/
@property(nonatomic, readwrite) int32_t delay;

@end

#pragma mark - TripUpdate_StopTimeEvent

typedef GPB_ENUM(TripUpdate_StopTimeEvent_FieldNumber) {
  TripUpdate_StopTimeEvent_FieldNumber_Delay = 1,
  TripUpdate_StopTimeEvent_FieldNumber_Time = 2,
  TripUpdate_StopTimeEvent_FieldNumber_Uncertainty = 3,
};

/**
 * Timing information for a single predicted event (either arrival or
 * departure).
 * Timing consists of delay and/or estimated time, and uncertainty.
 * - delay should be used when the prediction is given relative to some
 *   existing schedule in GTFS.
 * - time should be given whether there is a predicted schedule or not. If
 *   both time and delay are specified, time will take precedence
 *   (although normally, time, if given for a scheduled trip, should be
 *   equal to scheduled time in GTFS + delay).
 *
 * Uncertainty applies equally to both time and delay.
 * The uncertainty roughly specifies the expected error in true delay (but
 * note, we don't yet define its precise statistical meaning). It's possible
 * for the uncertainty to be 0, for example for trains that are driven under
 * computer timing control.
 **/
@interface TripUpdate_StopTimeEvent : GPBMessage

/**
 * Delay (in seconds) can be positive (meaning that the vehicle is late) or
 * negative (meaning that the vehicle is ahead of schedule). Delay of 0
 * means that the vehicle is exactly on time.
 * optional int32 delay = 1;
 **/
@property(nonatomic, readwrite) int32_t delay;

/**
 * Event as absolute time.
 * In Unix time (i.e., number of seconds since January 1st 1970 00:00:00
 * UTC).
 * optional int64 time = 2;
 **/
@property(nonatomic, readwrite) int64_t time;

/**
 * If uncertainty is omitted, it is interpreted as unknown.
 * If the prediction is unknown or too uncertain, the delay (or time) field
 * should be empty. In such case, the uncertainty field is ignored.
 * To specify a completely certain prediction, set its uncertainty to 0.
 * optional int32 uncertainty = 3;
 **/
@property(nonatomic, readwrite) int32_t uncertainty;

@end

#pragma mark - TripUpdate_StopTimeUpdate

typedef GPB_ENUM(TripUpdate_StopTimeUpdate_FieldNumber) {
  TripUpdate_StopTimeUpdate_FieldNumber_StopSequence = 1,
  TripUpdate_StopTimeUpdate_FieldNumber_Arrival = 2,
  TripUpdate_StopTimeUpdate_FieldNumber_Departure = 3,
  TripUpdate_StopTimeUpdate_FieldNumber_StopId = 4,
  TripUpdate_StopTimeUpdate_FieldNumber_ScheduleRelationship = 5,
};

/**
 * Realtime update for arrival and/or departure events for a given stop on a
 * trip. Updates can be supplied for both past and future events.
 * The producer is allowed, although not required, to drop past events.
 **/
@interface TripUpdate_StopTimeUpdate : GPBMessage

/**
 * Must be the same as in stop_times.txt in the corresponding GTFS feed.
 * optional uint32 stop_sequence = 1;
 **/
@property(nonatomic, readwrite) uint32_t stopSequence;

/**
 * Must be the same as in stops.txt in the corresponding GTFS feed.
 * optional string stop_id = 4;
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *stopId;

/** optional StopTimeEvent arrival = 2; */
@property(nonatomic, readwrite, strong, null_resettable) TripUpdate_StopTimeEvent *arrival;
/** Test to see if @c arrival has been set. */
@property(nonatomic, readwrite) BOOL hasArrival;

/** optional StopTimeEvent departure = 3; */
@property(nonatomic, readwrite, strong, null_resettable) TripUpdate_StopTimeEvent *departure;
/** Test to see if @c departure has been set. */
@property(nonatomic, readwrite) BOOL hasDeparture;

/**
 * optional ScheduleRelationship schedule_relationship = 5
 *    [default = SCHEDULED];
 **/
@property(nonatomic, readwrite) TripUpdate_StopTimeUpdate_ScheduleRelationship scheduleRelationship;

@end

/**
 * Fetches the raw value of a @c TripUpdate_StopTimeUpdate's @c scheduleRelationship property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t TripUpdate_StopTimeUpdate_ScheduleRelationship_RawValue(TripUpdate_StopTimeUpdate *message);
/**
 * Sets the raw value of an @c TripUpdate_StopTimeUpdate's @c scheduleRelationship property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetTripUpdate_StopTimeUpdate_ScheduleRelationship_RawValue(TripUpdate_StopTimeUpdate *message, int32_t value);

#pragma mark - VehiclePosition

typedef GPB_ENUM(VehiclePosition_FieldNumber) {
  VehiclePosition_FieldNumber_Trip = 1,
  VehiclePosition_FieldNumber_Position = 2,
  VehiclePosition_FieldNumber_CurrentStopSequence = 3,
  VehiclePosition_FieldNumber_CurrentStatus = 4,
  VehiclePosition_FieldNumber_Timestamp = 5,
  VehiclePosition_FieldNumber_CongestionLevel = 6,
  VehiclePosition_FieldNumber_StopId = 7,
  VehiclePosition_FieldNumber_Vehicle = 8,
  VehiclePosition_FieldNumber_OccupancyStatus = 9,
};

/**
 * Realtime positioning information for a given vehicle.
 **/
@interface VehiclePosition : GPBMessage

/**
 * The Trip that this vehicle is serving.
 * Can be empty or partial if the vehicle can not be identified with a given
 * trip instance.
 * optional TripDescriptor trip = 1;
 **/
@property(nonatomic, readwrite, strong, null_resettable) TripDescriptor *trip;
/** Test to see if @c trip has been set. */
@property(nonatomic, readwrite) BOOL hasTrip;

/**
 * Additional information on the vehicle that is serving this trip.
 * optional VehicleDescriptor vehicle = 8;
 **/
@property(nonatomic, readwrite, strong, null_resettable) VehicleDescriptor *vehicle;
/** Test to see if @c vehicle has been set. */
@property(nonatomic, readwrite) BOOL hasVehicle;

/**
 * Current position of this vehicle.
 * optional Position position = 2;
 **/
@property(nonatomic, readwrite, strong, null_resettable) Position *position;
/** Test to see if @c position has been set. */
@property(nonatomic, readwrite) BOOL hasPosition;

/**
 * The stop sequence index of the current stop. The meaning of
 * current_stop_sequence (i.e., the stop that it refers to) is determined by
 * current_status.
 * If current_status is missing IN_TRANSIT_TO is assumed.
 * optional uint32 current_stop_sequence = 3;
 **/
@property(nonatomic, readwrite) uint32_t currentStopSequence;

/**
 * Identifies the current stop. The value must be the same as in stops.txt in
 * the corresponding GTFS feed.
 * optional string stop_id = 7;
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *stopId;

/**
 * The exact status of the vehicle with respect to the current stop.
 * Ignored if current_stop_sequence is missing.
 * optional VehicleStopStatus current_status = 4 [default = IN_TRANSIT_TO];
 **/
@property(nonatomic, readwrite) VehiclePosition_VehicleStopStatus currentStatus;

/**
 * Moment at which the vehicle's position was measured. In POSIX time
 * (i.e., number of seconds since January 1st 1970 00:00:00 UTC).
 * optional uint64 timestamp = 5;
 **/
@property(nonatomic, readwrite) uint64_t timestamp;

/** optional CongestionLevel congestion_level = 6; */
@property(nonatomic, readwrite) VehiclePosition_CongestionLevel congestionLevel;

/** optional OccupancyStatus occupancy_status = 9; */
@property(nonatomic, readwrite) VehiclePosition_OccupancyStatus occupancyStatus;

@end

/**
 * Fetches the raw value of a @c VehiclePosition's @c currentStatus property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t VehiclePosition_CurrentStatus_RawValue(VehiclePosition *message);
/**
 * Sets the raw value of an @c VehiclePosition's @c currentStatus property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetVehiclePosition_CurrentStatus_RawValue(VehiclePosition *message, int32_t value);

/**
 * Fetches the raw value of a @c VehiclePosition's @c congestionLevel property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t VehiclePosition_CongestionLevel_RawValue(VehiclePosition *message);
/**
 * Sets the raw value of an @c VehiclePosition's @c congestionLevel property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetVehiclePosition_CongestionLevel_RawValue(VehiclePosition *message, int32_t value);

/**
 * Fetches the raw value of a @c VehiclePosition's @c occupancyStatus property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t VehiclePosition_OccupancyStatus_RawValue(VehiclePosition *message);
/**
 * Sets the raw value of an @c VehiclePosition's @c occupancyStatus property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetVehiclePosition_OccupancyStatus_RawValue(VehiclePosition *message, int32_t value);

#pragma mark - Alert

typedef GPB_ENUM(Alert_FieldNumber) {
  Alert_FieldNumber_ActivePeriodArray = 1,
  Alert_FieldNumber_InformedEntityArray = 5,
  Alert_FieldNumber_Cause = 6,
  Alert_FieldNumber_Effect = 7,
  Alert_FieldNumber_URL = 8,
  Alert_FieldNumber_HeaderText = 10,
  Alert_FieldNumber_DescriptionText = 11,
};

/**
 * An alert, indicating some sort of incident in the public transit network.
 **/
@interface Alert : GPBMessage

/**
 * Time when the alert should be shown to the user. If missing, the
 * alert will be shown as long as it appears in the feed.
 * If multiple ranges are given, the alert will be shown during all of them.
 **/
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<TimeRange*> *activePeriodArray;
/** The number of items in @c activePeriodArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger activePeriodArray_Count;

/** Entities whose users we should notify of this alert. */
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<EntitySelector*> *informedEntityArray;
/** The number of items in @c informedEntityArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger informedEntityArray_Count;

/** optional Cause cause = 6 [default = UNKNOWN_CAUSE]; */
@property(nonatomic, readwrite) Alert_Cause cause;

/** optional Effect effect = 7 [default = UNKNOWN_EFFECT]; */
@property(nonatomic, readwrite) Alert_Effect effect;

/**
 * The URL which provides additional information about the alert.
 * optional TranslatedString url = 8;
 **/
@property(nonatomic, readwrite, strong, null_resettable) TranslatedString *URL;
/** Test to see if @c URL has been set. */
@property(nonatomic, readwrite) BOOL hasURL;

/**
 * Alert header. Contains a short summary of the alert text as plain-text.
 * optional TranslatedString header_text = 10;
 **/
@property(nonatomic, readwrite, strong, null_resettable) TranslatedString *headerText;
/** Test to see if @c headerText has been set. */
@property(nonatomic, readwrite) BOOL hasHeaderText;

/**
 * Full description for the alert as plain-text. The information in the
 * description should add to the information of the header.
 * optional TranslatedString description_text = 11;
 **/
@property(nonatomic, readwrite, strong, null_resettable) TranslatedString *descriptionText;
/** Test to see if @c descriptionText has been set. */
@property(nonatomic, readwrite) BOOL hasDescriptionText;

@end

/**
 * Fetches the raw value of a @c Alert's @c cause property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t Alert_Cause_RawValue(Alert *message);
/**
 * Sets the raw value of an @c Alert's @c cause property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetAlert_Cause_RawValue(Alert *message, int32_t value);

/**
 * Fetches the raw value of a @c Alert's @c effect property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t Alert_Effect_RawValue(Alert *message);
/**
 * Sets the raw value of an @c Alert's @c effect property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetAlert_Effect_RawValue(Alert *message, int32_t value);

#pragma mark - TimeRange

typedef GPB_ENUM(TimeRange_FieldNumber) {
  TimeRange_FieldNumber_Start = 1,
  TimeRange_FieldNumber_End = 2,
};

/**
 * A time interval. The interval is considered active at time 't' if 't' is
 * greater than or equal to the start time and less than the end time.
 **/
@interface TimeRange : GPBMessage

/**
 * Start time, in POSIX time (i.e., number of seconds since January 1st 1970
 * 00:00:00 UTC).
 * If missing, the interval starts at minus infinity.
 * optional uint64 start = 1;
 **/
@property(nonatomic, readwrite) uint64_t start;

/**
 * End time, in POSIX time (i.e., number of seconds since January 1st 1970
 * 00:00:00 UTC).
 * If missing, the interval ends at plus infinity.
 * optional uint64 end = 2;
 **/
@property(nonatomic, readwrite) uint64_t end;

@end

#pragma mark - Position

typedef GPB_ENUM(Position_FieldNumber) {
  Position_FieldNumber_Latitude = 1,
  Position_FieldNumber_Longitude = 2,
  Position_FieldNumber_Bearing = 3,
  Position_FieldNumber_Odometer = 4,
  Position_FieldNumber_Speed = 5,
};

/**
 * A position.
 **/
@interface Position : GPBMessage

/**
 * Degrees North, in the WGS-84 coordinate system.
 * required float latitude = 1;
 **/
@property(nonatomic, readwrite) float latitude;

/**
 * Degrees East, in the WGS-84 coordinate system.
 * required float longitude = 2;
 **/
@property(nonatomic, readwrite) float longitude;

/**
 * Bearing, in degrees, clockwise from North, i.e., 0 is North and 90 is East.
 * This can be the compass bearing, or the direction towards the next stop
 * or intermediate location.
 * This should not be direction deduced from the sequence of previous
 * positions, which can be computed from previous data.
 * optional float bearing = 3;
 **/
@property(nonatomic, readwrite) float bearing;

/**
 * Odometer value, in meters.
 * optional double odometer = 4;
 **/
@property(nonatomic, readwrite) double odometer;

/**
 * Momentary speed measured by the vehicle, in meters per second.
 * optional float speed = 5;
 **/
@property(nonatomic, readwrite) float speed;

@end

#pragma mark - TripDescriptor

typedef GPB_ENUM(TripDescriptor_FieldNumber) {
  TripDescriptor_FieldNumber_TripId = 1,
  TripDescriptor_FieldNumber_StartTime = 2,
  TripDescriptor_FieldNumber_StartDate = 3,
  TripDescriptor_FieldNumber_ScheduleRelationship = 4,
  TripDescriptor_FieldNumber_RouteId = 5,
  TripDescriptor_FieldNumber_DirectionId = 6,
};

/**
 * A descriptor that identifies an instance of a GTFS trip, or all instances of
 * a trip along a route.
 * - To specify a single trip instance, the trip_id (and if necessary,
 *   start_time) is set. If route_id is also set, then it should be same as one
 *   that the given trip corresponds to.
 * - To specify all the trips along a given route, only the route_id should be
 *   set. Note that if the trip_id is not known, then stop sequence ids in
 *   TripUpdate are not sufficient, and stop_ids must be provided as well. In
 *   addition, absolute arrival/departure times must be provided.
 **/
@interface TripDescriptor : GPBMessage

/**
 * The trip_id from the GTFS feed that this selector refers to.
 * For non frequency-based trips, this field is enough to uniquely identify
 * the trip. For frequency-based trip, start_time and start_date might also be
 * necessary.
 * optional string trip_id = 1;
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *tripId;

/**
 * The route_id from the GTFS that this selector refers to.
 * optional string route_id = 5;
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *routeId;

/**
 * The direction_id from the GTFS feed trips.txt file, indicating the
 * direction of travel for trips this selector refers to. This field is
 * still experimental, and subject to change. It may be formally adopted in
 * the future.
 * optional uint32 direction_id = 6;
 **/
@property(nonatomic, readwrite) uint32_t directionId;

/**
 * The initially scheduled start time of this trip instance.
 * When the trip_id corresponds to a non-frequency-based trip, this field
 * should either be omitted or be equal to the value in the GTFS feed. When
 * the trip_id correponds to a frequency-based trip, the start_time must be
 * specified for trip updates and vehicle positions. If the trip corresponds
 * to exact_times=1 GTFS record, then start_time must be some multiple
 * (including zero) of headway_secs later than frequencies.txt start_time for
 * the corresponding time period. If the trip corresponds to exact_times=0,
 * then its start_time may be arbitrary, and is initially expected to be the
 * first departure of the trip. Once established, the start_time of this
 * frequency-based trip should be considered immutable, even if the first
 * departure time changes -- that time change may instead be reflected in a
 * StopTimeUpdate.
 * Format and semantics of the field is same as that of
 * GTFS/frequencies.txt/start_time, e.g., 11:15:35 or 25:15:35.
 * optional string start_time = 2;
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *startTime;

/**
 * The scheduled start date of this trip instance.
 * Must be provided to disambiguate trips that are so late as to collide with
 * a scheduled trip on a next day. For example, for a train that departs 8:00
 * and 20:00 every day, and is 12 hours late, there would be two distinct
 * trips on the same time.
 * This field can be provided but is not mandatory for schedules in which such
 * collisions are impossible - for example, a service running on hourly
 * schedule where a vehicle that is one hour late is not considered to be
 * related to schedule anymore.
 * In YYYYMMDD format.
 * optional string start_date = 3;
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *startDate;

/** optional ScheduleRelationship schedule_relationship = 4; */
@property(nonatomic, readwrite) TripDescriptor_ScheduleRelationship scheduleRelationship;

@end

/**
 * Fetches the raw value of a @c TripDescriptor's @c scheduleRelationship property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t TripDescriptor_ScheduleRelationship_RawValue(TripDescriptor *message);
/**
 * Sets the raw value of an @c TripDescriptor's @c scheduleRelationship property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetTripDescriptor_ScheduleRelationship_RawValue(TripDescriptor *message, int32_t value);

#pragma mark - VehicleDescriptor

typedef GPB_ENUM(VehicleDescriptor_FieldNumber) {
  VehicleDescriptor_FieldNumber_Id_p = 1,
  VehicleDescriptor_FieldNumber_Label = 2,
  VehicleDescriptor_FieldNumber_LicensePlate = 3,
};

/**
 * Identification information for the vehicle performing the trip.
 **/
@interface VehicleDescriptor : GPBMessage

/**
 * Internal system identification of the vehicle. Should be unique per
 * vehicle, and can be used for tracking the vehicle as it proceeds through
 * the system.
 * optional string id = 1;
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *id_p;

/**
 * User visible label, i.e., something that must be shown to the passenger to
 * help identify the correct vehicle.
 * optional string label = 2;
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *label;

/**
 * The license plate of the vehicle.
 * optional string license_plate = 3;
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *licensePlate;

@end

#pragma mark - EntitySelector

typedef GPB_ENUM(EntitySelector_FieldNumber) {
  EntitySelector_FieldNumber_AgencyId = 1,
  EntitySelector_FieldNumber_RouteId = 2,
  EntitySelector_FieldNumber_RouteType = 3,
  EntitySelector_FieldNumber_Trip = 4,
  EntitySelector_FieldNumber_StopId = 5,
};

/**
 * A selector for an entity in a GTFS feed.
 **/
@interface EntitySelector : GPBMessage

/**
 * The values of the fields should correspond to the appropriate fields in the
 * GTFS feed.
 * At least one specifier must be given. If several are given, then the
 * matching has to apply to all the given specifiers.
 * optional string agency_id = 1;
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *agencyId;

/** optional string route_id = 2; */
@property(nonatomic, readwrite, copy, null_resettable) NSString *routeId;

/**
 * corresponds to route_type in GTFS.
 * optional int32 route_type = 3;
 **/
@property(nonatomic, readwrite) int32_t routeType;

/** optional TripDescriptor trip = 4; */
@property(nonatomic, readwrite, strong, null_resettable) TripDescriptor *trip;
/** Test to see if @c trip has been set. */
@property(nonatomic, readwrite) BOOL hasTrip;

/** optional string stop_id = 5; */
@property(nonatomic, readwrite, copy, null_resettable) NSString *stopId;

@end

#pragma mark - TranslatedString

typedef GPB_ENUM(TranslatedString_FieldNumber) {
  TranslatedString_FieldNumber_TranslationArray = 1,
};

/**
 * An internationalized message containing per-language versions of a snippet of
 * text or a URL.
 * One of the strings from a message will be picked up. The resolution proceeds
 * as follows:
 * 1. If the UI language matches the language code of a translation,
 *    the first matching translation is picked.
 * 2. If a default UI language (e.g., English) matches the language code of a
 *    translation, the first matching translation is picked.
 * 3. If some translation has an unspecified language code, that translation is
 *    picked.
 **/
@interface TranslatedString : GPBMessage

/** At least one translation must be provided. */
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<TranslatedString_Translation*> *translationArray;
/** The number of items in @c translationArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger translationArray_Count;

@end

#pragma mark - TranslatedString_Translation

typedef GPB_ENUM(TranslatedString_Translation_FieldNumber) {
  TranslatedString_Translation_FieldNumber_Text = 1,
  TranslatedString_Translation_FieldNumber_Language = 2,
};

@interface TranslatedString_Translation : GPBMessage

/**
 * A UTF-8 string containing the message.
 * required string text = 1;
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *text;

/**
 * BCP-47 language code. Can be omitted if the language is unknown or if
 * no i18n is done at all for the feed. At most one translation is
 * allowed to have an unspecified language tag.
 * optional string language = 2;
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *language;

@end

NS_ASSUME_NONNULL_END

CF_EXTERN_C_END

#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
