// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: gtfs-realtime.proto3

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "GtfsRealtimeProto3.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - GtfsRealtimeProto3Root

@implementation GtfsRealtimeProto3Root

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - GtfsRealtimeProto3Root_FileDescriptor

static GPBFileDescriptor *GtfsRealtimeProto3Root_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"transit_realtime"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - FeedMessage

@implementation FeedMessage

@dynamic hasHeader, header;
@dynamic entityArray, entityArray_Count;

typedef struct FeedMessage__storage_ {
  uint32_t _has_storage_[1];
  FeedHeader *header;
  NSMutableArray *entityArray;
} FeedMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "header",
        .dataTypeSpecific.className = GPBStringifySymbol(FeedHeader),
        .number = FeedMessage_FieldNumber_Header,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FeedMessage__storage_, header),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "entityArray",
        .dataTypeSpecific.className = GPBStringifySymbol(FeedEntity),
        .number = FeedMessage_FieldNumber_EntityArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(FeedMessage__storage_, entityArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FeedMessage class]
                                     rootClass:[GtfsRealtimeProto3Root class]
                                          file:GtfsRealtimeProto3Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FeedMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FeedHeader

@implementation FeedHeader

@dynamic gtfsRealtimeVersion;
@dynamic incrementality;
@dynamic timestamp;

typedef struct FeedHeader__storage_ {
  uint32_t _has_storage_[1];
  FeedHeader_Incrementality incrementality;
  NSString *gtfsRealtimeVersion;
  uint64_t timestamp;
} FeedHeader__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "gtfsRealtimeVersion",
        .dataTypeSpecific.className = NULL,
        .number = FeedHeader_FieldNumber_GtfsRealtimeVersion,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FeedHeader__storage_, gtfsRealtimeVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "incrementality",
        .dataTypeSpecific.enumDescFunc = FeedHeader_Incrementality_EnumDescriptor,
        .number = FeedHeader_FieldNumber_Incrementality,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FeedHeader__storage_, incrementality),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = FeedHeader_FieldNumber_Timestamp,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(FeedHeader__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FeedHeader class]
                                     rootClass:[GtfsRealtimeProto3Root class]
                                          file:GtfsRealtimeProto3Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FeedHeader__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t FeedHeader_Incrementality_RawValue(FeedHeader *message) {
  GPBDescriptor *descriptor = [FeedHeader descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:FeedHeader_FieldNumber_Incrementality];
  return GPBGetMessageInt32Field(message, field);
}

void SetFeedHeader_Incrementality_RawValue(FeedHeader *message, int32_t value) {
  GPBDescriptor *descriptor = [FeedHeader descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:FeedHeader_FieldNumber_Incrementality];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum FeedHeader_Incrementality

GPBEnumDescriptor *FeedHeader_Incrementality_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "FullDataset\000Differential\000";
    static const int32_t values[] = {
        FeedHeader_Incrementality_FullDataset,
        FeedHeader_Incrementality_Differential,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(FeedHeader_Incrementality)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:FeedHeader_Incrementality_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL FeedHeader_Incrementality_IsValidValue(int32_t value__) {
  switch (value__) {
    case FeedHeader_Incrementality_FullDataset:
    case FeedHeader_Incrementality_Differential:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - FeedEntity

@implementation FeedEntity

@dynamic id_p;
@dynamic isDeleted;
@dynamic hasTripUpdate, tripUpdate;
@dynamic hasVehicle, vehicle;
@dynamic hasAlert, alert;

typedef struct FeedEntity__storage_ {
  uint32_t _has_storage_[1];
  NSString *id_p;
  TripUpdate *tripUpdate;
  VehiclePosition *vehicle;
  Alert *alert;
} FeedEntity__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = FeedEntity_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FeedEntity__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isDeleted",
        .dataTypeSpecific.className = NULL,
        .number = FeedEntity_FieldNumber_IsDeleted,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "tripUpdate",
        .dataTypeSpecific.className = GPBStringifySymbol(TripUpdate),
        .number = FeedEntity_FieldNumber_TripUpdate,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(FeedEntity__storage_, tripUpdate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "vehicle",
        .dataTypeSpecific.className = GPBStringifySymbol(VehiclePosition),
        .number = FeedEntity_FieldNumber_Vehicle,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(FeedEntity__storage_, vehicle),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "alert",
        .dataTypeSpecific.className = GPBStringifySymbol(Alert),
        .number = FeedEntity_FieldNumber_Alert,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(FeedEntity__storage_, alert),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FeedEntity class]
                                     rootClass:[GtfsRealtimeProto3Root class]
                                          file:GtfsRealtimeProto3Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FeedEntity__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TripUpdate

@implementation TripUpdate

@dynamic hasTrip, trip;
@dynamic hasVehicle, vehicle;
@dynamic stopTimeUpdateArray, stopTimeUpdateArray_Count;
@dynamic timestamp;
@dynamic delay;

typedef struct TripUpdate__storage_ {
  uint32_t _has_storage_[1];
  int32_t delay;
  TripDescriptor *trip;
  NSMutableArray *stopTimeUpdateArray;
  VehicleDescriptor *vehicle;
  uint64_t timestamp;
} TripUpdate__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "trip",
        .dataTypeSpecific.className = GPBStringifySymbol(TripDescriptor),
        .number = TripUpdate_FieldNumber_Trip,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TripUpdate__storage_, trip),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "stopTimeUpdateArray",
        .dataTypeSpecific.className = GPBStringifySymbol(TripUpdate_StopTimeUpdate),
        .number = TripUpdate_FieldNumber_StopTimeUpdateArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TripUpdate__storage_, stopTimeUpdateArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "vehicle",
        .dataTypeSpecific.className = GPBStringifySymbol(VehicleDescriptor),
        .number = TripUpdate_FieldNumber_Vehicle,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TripUpdate__storage_, vehicle),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = TripUpdate_FieldNumber_Timestamp,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TripUpdate__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "delay",
        .dataTypeSpecific.className = NULL,
        .number = TripUpdate_FieldNumber_Delay,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(TripUpdate__storage_, delay),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TripUpdate class]
                                     rootClass:[GtfsRealtimeProto3Root class]
                                          file:GtfsRealtimeProto3Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TripUpdate__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TripUpdate_StopTimeEvent

@implementation TripUpdate_StopTimeEvent

@dynamic delay;
@dynamic time;
@dynamic uncertainty;

typedef struct TripUpdate_StopTimeEvent__storage_ {
  uint32_t _has_storage_[1];
  int32_t delay;
  int32_t uncertainty;
  int64_t time;
} TripUpdate_StopTimeEvent__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "delay",
        .dataTypeSpecific.className = NULL,
        .number = TripUpdate_StopTimeEvent_FieldNumber_Delay,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TripUpdate_StopTimeEvent__storage_, delay),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "time",
        .dataTypeSpecific.className = NULL,
        .number = TripUpdate_StopTimeEvent_FieldNumber_Time,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TripUpdate_StopTimeEvent__storage_, time),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "uncertainty",
        .dataTypeSpecific.className = NULL,
        .number = TripUpdate_StopTimeEvent_FieldNumber_Uncertainty,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TripUpdate_StopTimeEvent__storage_, uncertainty),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TripUpdate_StopTimeEvent class]
                                     rootClass:[GtfsRealtimeProto3Root class]
                                          file:GtfsRealtimeProto3Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TripUpdate_StopTimeEvent__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(TripUpdate)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TripUpdate_StopTimeUpdate

@implementation TripUpdate_StopTimeUpdate

@dynamic stopSequence;
@dynamic stopId;
@dynamic hasArrival, arrival;
@dynamic hasDeparture, departure;
@dynamic scheduleRelationship;

typedef struct TripUpdate_StopTimeUpdate__storage_ {
  uint32_t _has_storage_[1];
  uint32_t stopSequence;
  TripUpdate_StopTimeUpdate_ScheduleRelationship scheduleRelationship;
  TripUpdate_StopTimeEvent *arrival;
  TripUpdate_StopTimeEvent *departure;
  NSString *stopId;
} TripUpdate_StopTimeUpdate__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "stopSequence",
        .dataTypeSpecific.className = NULL,
        .number = TripUpdate_StopTimeUpdate_FieldNumber_StopSequence,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TripUpdate_StopTimeUpdate__storage_, stopSequence),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "arrival",
        .dataTypeSpecific.className = GPBStringifySymbol(TripUpdate_StopTimeEvent),
        .number = TripUpdate_StopTimeUpdate_FieldNumber_Arrival,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TripUpdate_StopTimeUpdate__storage_, arrival),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "departure",
        .dataTypeSpecific.className = GPBStringifySymbol(TripUpdate_StopTimeEvent),
        .number = TripUpdate_StopTimeUpdate_FieldNumber_Departure,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(TripUpdate_StopTimeUpdate__storage_, departure),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "stopId",
        .dataTypeSpecific.className = NULL,
        .number = TripUpdate_StopTimeUpdate_FieldNumber_StopId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TripUpdate_StopTimeUpdate__storage_, stopId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "scheduleRelationship",
        .dataTypeSpecific.enumDescFunc = TripUpdate_StopTimeUpdate_ScheduleRelationship_EnumDescriptor,
        .number = TripUpdate_StopTimeUpdate_FieldNumber_ScheduleRelationship,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(TripUpdate_StopTimeUpdate__storage_, scheduleRelationship),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TripUpdate_StopTimeUpdate class]
                                     rootClass:[GtfsRealtimeProto3Root class]
                                          file:GtfsRealtimeProto3Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TripUpdate_StopTimeUpdate__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(TripUpdate)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t TripUpdate_StopTimeUpdate_ScheduleRelationship_RawValue(TripUpdate_StopTimeUpdate *message) {
  GPBDescriptor *descriptor = [TripUpdate_StopTimeUpdate descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:TripUpdate_StopTimeUpdate_FieldNumber_ScheduleRelationship];
  return GPBGetMessageInt32Field(message, field);
}

void SetTripUpdate_StopTimeUpdate_ScheduleRelationship_RawValue(TripUpdate_StopTimeUpdate *message, int32_t value) {
  GPBDescriptor *descriptor = [TripUpdate_StopTimeUpdate descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:TripUpdate_StopTimeUpdate_FieldNumber_ScheduleRelationship];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum TripUpdate_StopTimeUpdate_ScheduleRelationship

GPBEnumDescriptor *TripUpdate_StopTimeUpdate_ScheduleRelationship_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Scheduled\000Skipped\000NoData\000";
    static const int32_t values[] = {
        TripUpdate_StopTimeUpdate_ScheduleRelationship_Scheduled,
        TripUpdate_StopTimeUpdate_ScheduleRelationship_Skipped,
        TripUpdate_StopTimeUpdate_ScheduleRelationship_NoData,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(TripUpdate_StopTimeUpdate_ScheduleRelationship)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:TripUpdate_StopTimeUpdate_ScheduleRelationship_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL TripUpdate_StopTimeUpdate_ScheduleRelationship_IsValidValue(int32_t value__) {
  switch (value__) {
    case TripUpdate_StopTimeUpdate_ScheduleRelationship_Scheduled:
    case TripUpdate_StopTimeUpdate_ScheduleRelationship_Skipped:
    case TripUpdate_StopTimeUpdate_ScheduleRelationship_NoData:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - VehiclePosition

@implementation VehiclePosition

@dynamic hasTrip, trip;
@dynamic hasVehicle, vehicle;
@dynamic hasPosition, position;
@dynamic currentStopSequence;
@dynamic stopId;
@dynamic currentStatus;
@dynamic timestamp;
@dynamic congestionLevel;
@dynamic occupancyStatus;

typedef struct VehiclePosition__storage_ {
  uint32_t _has_storage_[1];
  uint32_t currentStopSequence;
  VehiclePosition_VehicleStopStatus currentStatus;
  VehiclePosition_CongestionLevel congestionLevel;
  VehiclePosition_OccupancyStatus occupancyStatus;
  TripDescriptor *trip;
  Position *position;
  NSString *stopId;
  VehicleDescriptor *vehicle;
  uint64_t timestamp;
} VehiclePosition__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "trip",
        .dataTypeSpecific.className = GPBStringifySymbol(TripDescriptor),
        .number = VehiclePosition_FieldNumber_Trip,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(VehiclePosition__storage_, trip),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "position",
        .dataTypeSpecific.className = GPBStringifySymbol(Position),
        .number = VehiclePosition_FieldNumber_Position,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(VehiclePosition__storage_, position),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "currentStopSequence",
        .dataTypeSpecific.className = NULL,
        .number = VehiclePosition_FieldNumber_CurrentStopSequence,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(VehiclePosition__storage_, currentStopSequence),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "currentStatus",
        .dataTypeSpecific.enumDescFunc = VehiclePosition_VehicleStopStatus_EnumDescriptor,
        .number = VehiclePosition_FieldNumber_CurrentStatus,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(VehiclePosition__storage_, currentStatus),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = VehiclePosition_FieldNumber_Timestamp,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(VehiclePosition__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "congestionLevel",
        .dataTypeSpecific.enumDescFunc = VehiclePosition_CongestionLevel_EnumDescriptor,
        .number = VehiclePosition_FieldNumber_CongestionLevel,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(VehiclePosition__storage_, congestionLevel),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "stopId",
        .dataTypeSpecific.className = NULL,
        .number = VehiclePosition_FieldNumber_StopId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(VehiclePosition__storage_, stopId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "vehicle",
        .dataTypeSpecific.className = GPBStringifySymbol(VehicleDescriptor),
        .number = VehiclePosition_FieldNumber_Vehicle,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(VehiclePosition__storage_, vehicle),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "occupancyStatus",
        .dataTypeSpecific.enumDescFunc = VehiclePosition_OccupancyStatus_EnumDescriptor,
        .number = VehiclePosition_FieldNumber_OccupancyStatus,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(VehiclePosition__storage_, occupancyStatus),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[VehiclePosition class]
                                     rootClass:[GtfsRealtimeProto3Root class]
                                          file:GtfsRealtimeProto3Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VehiclePosition__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t VehiclePosition_CurrentStatus_RawValue(VehiclePosition *message) {
  GPBDescriptor *descriptor = [VehiclePosition descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:VehiclePosition_FieldNumber_CurrentStatus];
  return GPBGetMessageInt32Field(message, field);
}

void SetVehiclePosition_CurrentStatus_RawValue(VehiclePosition *message, int32_t value) {
  GPBDescriptor *descriptor = [VehiclePosition descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:VehiclePosition_FieldNumber_CurrentStatus];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t VehiclePosition_CongestionLevel_RawValue(VehiclePosition *message) {
  GPBDescriptor *descriptor = [VehiclePosition descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:VehiclePosition_FieldNumber_CongestionLevel];
  return GPBGetMessageInt32Field(message, field);
}

void SetVehiclePosition_CongestionLevel_RawValue(VehiclePosition *message, int32_t value) {
  GPBDescriptor *descriptor = [VehiclePosition descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:VehiclePosition_FieldNumber_CongestionLevel];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t VehiclePosition_OccupancyStatus_RawValue(VehiclePosition *message) {
  GPBDescriptor *descriptor = [VehiclePosition descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:VehiclePosition_FieldNumber_OccupancyStatus];
  return GPBGetMessageInt32Field(message, field);
}

void SetVehiclePosition_OccupancyStatus_RawValue(VehiclePosition *message, int32_t value) {
  GPBDescriptor *descriptor = [VehiclePosition descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:VehiclePosition_FieldNumber_OccupancyStatus];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum VehiclePosition_VehicleStopStatus

GPBEnumDescriptor *VehiclePosition_VehicleStopStatus_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "IncomingAt\000StoppedAt\000InTransitTo\000";
    static const int32_t values[] = {
        VehiclePosition_VehicleStopStatus_IncomingAt,
        VehiclePosition_VehicleStopStatus_StoppedAt,
        VehiclePosition_VehicleStopStatus_InTransitTo,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(VehiclePosition_VehicleStopStatus)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:VehiclePosition_VehicleStopStatus_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL VehiclePosition_VehicleStopStatus_IsValidValue(int32_t value__) {
  switch (value__) {
    case VehiclePosition_VehicleStopStatus_IncomingAt:
    case VehiclePosition_VehicleStopStatus_StoppedAt:
    case VehiclePosition_VehicleStopStatus_InTransitTo:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum VehiclePosition_CongestionLevel

GPBEnumDescriptor *VehiclePosition_CongestionLevel_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "UnknownCongestionLevel\000RunningSmoothly\000S"
        "topAndGo\000Congestion\000SevereCongestion\000";
    static const int32_t values[] = {
        VehiclePosition_CongestionLevel_UnknownCongestionLevel,
        VehiclePosition_CongestionLevel_RunningSmoothly,
        VehiclePosition_CongestionLevel_StopAndGo,
        VehiclePosition_CongestionLevel_Congestion,
        VehiclePosition_CongestionLevel_SevereCongestion,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(VehiclePosition_CongestionLevel)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:VehiclePosition_CongestionLevel_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL VehiclePosition_CongestionLevel_IsValidValue(int32_t value__) {
  switch (value__) {
    case VehiclePosition_CongestionLevel_UnknownCongestionLevel:
    case VehiclePosition_CongestionLevel_RunningSmoothly:
    case VehiclePosition_CongestionLevel_StopAndGo:
    case VehiclePosition_CongestionLevel_Congestion:
    case VehiclePosition_CongestionLevel_SevereCongestion:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum VehiclePosition_OccupancyStatus

GPBEnumDescriptor *VehiclePosition_OccupancyStatus_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Empty\000ManySeatsAvailable\000FewSeatsAvailab"
        "le\000StandingRoomOnly\000CrushedStandingRoomO"
        "nly\000Full\000NotAcceptingPassengers\000";
    static const int32_t values[] = {
        VehiclePosition_OccupancyStatus_Empty,
        VehiclePosition_OccupancyStatus_ManySeatsAvailable,
        VehiclePosition_OccupancyStatus_FewSeatsAvailable,
        VehiclePosition_OccupancyStatus_StandingRoomOnly,
        VehiclePosition_OccupancyStatus_CrushedStandingRoomOnly,
        VehiclePosition_OccupancyStatus_Full,
        VehiclePosition_OccupancyStatus_NotAcceptingPassengers,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(VehiclePosition_OccupancyStatus)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:VehiclePosition_OccupancyStatus_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL VehiclePosition_OccupancyStatus_IsValidValue(int32_t value__) {
  switch (value__) {
    case VehiclePosition_OccupancyStatus_Empty:
    case VehiclePosition_OccupancyStatus_ManySeatsAvailable:
    case VehiclePosition_OccupancyStatus_FewSeatsAvailable:
    case VehiclePosition_OccupancyStatus_StandingRoomOnly:
    case VehiclePosition_OccupancyStatus_CrushedStandingRoomOnly:
    case VehiclePosition_OccupancyStatus_Full:
    case VehiclePosition_OccupancyStatus_NotAcceptingPassengers:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Alert

@implementation Alert

@dynamic activePeriodArray, activePeriodArray_Count;
@dynamic informedEntityArray, informedEntityArray_Count;
@dynamic cause;
@dynamic effect;
@dynamic hasURL, URL;
@dynamic hasHeaderText, headerText;
@dynamic hasDescriptionText, descriptionText;

typedef struct Alert__storage_ {
  uint32_t _has_storage_[1];
  Alert_Cause cause;
  Alert_Effect effect;
  NSMutableArray *activePeriodArray;
  NSMutableArray *informedEntityArray;
  TranslatedString *URL;
  TranslatedString *headerText;
  TranslatedString *descriptionText;
} Alert__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "activePeriodArray",
        .dataTypeSpecific.className = GPBStringifySymbol(TimeRange),
        .number = Alert_FieldNumber_ActivePeriodArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Alert__storage_, activePeriodArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "informedEntityArray",
        .dataTypeSpecific.className = GPBStringifySymbol(EntitySelector),
        .number = Alert_FieldNumber_InformedEntityArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Alert__storage_, informedEntityArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "cause",
        .dataTypeSpecific.enumDescFunc = Alert_Cause_EnumDescriptor,
        .number = Alert_FieldNumber_Cause,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Alert__storage_, cause),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "effect",
        .dataTypeSpecific.enumDescFunc = Alert_Effect_EnumDescriptor,
        .number = Alert_FieldNumber_Effect,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Alert__storage_, effect),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "URL",
        .dataTypeSpecific.className = GPBStringifySymbol(TranslatedString),
        .number = Alert_FieldNumber_URL,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Alert__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "headerText",
        .dataTypeSpecific.className = GPBStringifySymbol(TranslatedString),
        .number = Alert_FieldNumber_HeaderText,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Alert__storage_, headerText),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "descriptionText",
        .dataTypeSpecific.className = GPBStringifySymbol(TranslatedString),
        .number = Alert_FieldNumber_DescriptionText,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Alert__storage_, descriptionText),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Alert class]
                                     rootClass:[GtfsRealtimeProto3Root class]
                                          file:GtfsRealtimeProto3Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Alert__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\010!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Alert_Cause_RawValue(Alert *message) {
  GPBDescriptor *descriptor = [Alert descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Alert_FieldNumber_Cause];
  return GPBGetMessageInt32Field(message, field);
}

void SetAlert_Cause_RawValue(Alert *message, int32_t value) {
  GPBDescriptor *descriptor = [Alert descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Alert_FieldNumber_Cause];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t Alert_Effect_RawValue(Alert *message) {
  GPBDescriptor *descriptor = [Alert descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Alert_FieldNumber_Effect];
  return GPBGetMessageInt32Field(message, field);
}

void SetAlert_Effect_RawValue(Alert *message, int32_t value) {
  GPBDescriptor *descriptor = [Alert descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Alert_FieldNumber_Effect];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum Alert_Cause

GPBEnumDescriptor *Alert_Cause_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Proto3DefaultCause\000UnknownCause\000OtherCau"
        "se\000TechnicalProblem\000Strike\000Demonstration"
        "\000Accident\000Holiday\000Weather\000Maintenance\000Co"
        "nstruction\000PoliceActivity\000MedicalEmergen"
        "cy\000";
    static const int32_t values[] = {
        Alert_Cause_Proto3DefaultCause,
        Alert_Cause_UnknownCause,
        Alert_Cause_OtherCause,
        Alert_Cause_TechnicalProblem,
        Alert_Cause_Strike,
        Alert_Cause_Demonstration,
        Alert_Cause_Accident,
        Alert_Cause_Holiday,
        Alert_Cause_Weather,
        Alert_Cause_Maintenance,
        Alert_Cause_Construction,
        Alert_Cause_PoliceActivity,
        Alert_Cause_MedicalEmergency,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Alert_Cause)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Alert_Cause_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Alert_Cause_IsValidValue(int32_t value__) {
  switch (value__) {
    case Alert_Cause_Proto3DefaultCause:
    case Alert_Cause_UnknownCause:
    case Alert_Cause_OtherCause:
    case Alert_Cause_TechnicalProblem:
    case Alert_Cause_Strike:
    case Alert_Cause_Demonstration:
    case Alert_Cause_Accident:
    case Alert_Cause_Holiday:
    case Alert_Cause_Weather:
    case Alert_Cause_Maintenance:
    case Alert_Cause_Construction:
    case Alert_Cause_PoliceActivity:
    case Alert_Cause_MedicalEmergency:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum Alert_Effect

GPBEnumDescriptor *Alert_Effect_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Proto3DefaultEffect\000NoService\000ReducedSer"
        "vice\000SignificantDelays\000Detour\000Additional"
        "Service\000ModifiedService\000OtherEffect\000Unkn"
        "ownEffect\000StopMoved\000";
    static const int32_t values[] = {
        Alert_Effect_Proto3DefaultEffect,
        Alert_Effect_NoService,
        Alert_Effect_ReducedService,
        Alert_Effect_SignificantDelays,
        Alert_Effect_Detour,
        Alert_Effect_AdditionalService,
        Alert_Effect_ModifiedService,
        Alert_Effect_OtherEffect,
        Alert_Effect_UnknownEffect,
        Alert_Effect_StopMoved,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Alert_Effect)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Alert_Effect_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Alert_Effect_IsValidValue(int32_t value__) {
  switch (value__) {
    case Alert_Effect_Proto3DefaultEffect:
    case Alert_Effect_NoService:
    case Alert_Effect_ReducedService:
    case Alert_Effect_SignificantDelays:
    case Alert_Effect_Detour:
    case Alert_Effect_AdditionalService:
    case Alert_Effect_ModifiedService:
    case Alert_Effect_OtherEffect:
    case Alert_Effect_UnknownEffect:
    case Alert_Effect_StopMoved:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - TimeRange

@implementation TimeRange

@dynamic start;
@dynamic end;

typedef struct TimeRange__storage_ {
  uint32_t _has_storage_[1];
  uint64_t start;
  uint64_t end;
} TimeRange__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "start",
        .dataTypeSpecific.className = NULL,
        .number = TimeRange_FieldNumber_Start,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TimeRange__storage_, start),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "end",
        .dataTypeSpecific.className = NULL,
        .number = TimeRange_FieldNumber_End,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TimeRange__storage_, end),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TimeRange class]
                                     rootClass:[GtfsRealtimeProto3Root class]
                                          file:GtfsRealtimeProto3Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TimeRange__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Position

@implementation Position

@dynamic latitude;
@dynamic longitude;
@dynamic bearing;
@dynamic odometer;
@dynamic speed;

typedef struct Position__storage_ {
  uint32_t _has_storage_[1];
  float latitude;
  float longitude;
  float bearing;
  float speed;
  double odometer;
} Position__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "latitude",
        .dataTypeSpecific.className = NULL,
        .number = Position_FieldNumber_Latitude,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Position__storage_, latitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "longitude",
        .dataTypeSpecific.className = NULL,
        .number = Position_FieldNumber_Longitude,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Position__storage_, longitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "bearing",
        .dataTypeSpecific.className = NULL,
        .number = Position_FieldNumber_Bearing,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Position__storage_, bearing),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "odometer",
        .dataTypeSpecific.className = NULL,
        .number = Position_FieldNumber_Odometer,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Position__storage_, odometer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "speed",
        .dataTypeSpecific.className = NULL,
        .number = Position_FieldNumber_Speed,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Position__storage_, speed),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Position class]
                                     rootClass:[GtfsRealtimeProto3Root class]
                                          file:GtfsRealtimeProto3Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Position__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TripDescriptor

@implementation TripDescriptor

@dynamic tripId;
@dynamic routeId;
@dynamic directionId;
@dynamic startTime;
@dynamic startDate;
@dynamic scheduleRelationship;

typedef struct TripDescriptor__storage_ {
  uint32_t _has_storage_[1];
  TripDescriptor_ScheduleRelationship scheduleRelationship;
  uint32_t directionId;
  NSString *tripId;
  NSString *startTime;
  NSString *startDate;
  NSString *routeId;
} TripDescriptor__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tripId",
        .dataTypeSpecific.className = NULL,
        .number = TripDescriptor_FieldNumber_TripId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TripDescriptor__storage_, tripId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "startTime",
        .dataTypeSpecific.className = NULL,
        .number = TripDescriptor_FieldNumber_StartTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(TripDescriptor__storage_, startTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "startDate",
        .dataTypeSpecific.className = NULL,
        .number = TripDescriptor_FieldNumber_StartDate,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(TripDescriptor__storage_, startDate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "scheduleRelationship",
        .dataTypeSpecific.enumDescFunc = TripDescriptor_ScheduleRelationship_EnumDescriptor,
        .number = TripDescriptor_FieldNumber_ScheduleRelationship,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(TripDescriptor__storage_, scheduleRelationship),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "routeId",
        .dataTypeSpecific.className = NULL,
        .number = TripDescriptor_FieldNumber_RouteId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TripDescriptor__storage_, routeId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "directionId",
        .dataTypeSpecific.className = NULL,
        .number = TripDescriptor_FieldNumber_DirectionId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TripDescriptor__storage_, directionId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TripDescriptor class]
                                     rootClass:[GtfsRealtimeProto3Root class]
                                          file:GtfsRealtimeProto3Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TripDescriptor__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t TripDescriptor_ScheduleRelationship_RawValue(TripDescriptor *message) {
  GPBDescriptor *descriptor = [TripDescriptor descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:TripDescriptor_FieldNumber_ScheduleRelationship];
  return GPBGetMessageInt32Field(message, field);
}

void SetTripDescriptor_ScheduleRelationship_RawValue(TripDescriptor *message, int32_t value) {
  GPBDescriptor *descriptor = [TripDescriptor descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:TripDescriptor_FieldNumber_ScheduleRelationship];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum TripDescriptor_ScheduleRelationship

GPBEnumDescriptor *TripDescriptor_ScheduleRelationship_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Scheduled\000Added\000Unscheduled\000Canceled\000";
    static const int32_t values[] = {
        TripDescriptor_ScheduleRelationship_Scheduled,
        TripDescriptor_ScheduleRelationship_Added,
        TripDescriptor_ScheduleRelationship_Unscheduled,
        TripDescriptor_ScheduleRelationship_Canceled,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(TripDescriptor_ScheduleRelationship)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:TripDescriptor_ScheduleRelationship_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL TripDescriptor_ScheduleRelationship_IsValidValue(int32_t value__) {
  switch (value__) {
    case TripDescriptor_ScheduleRelationship_Scheduled:
    case TripDescriptor_ScheduleRelationship_Added:
    case TripDescriptor_ScheduleRelationship_Unscheduled:
    case TripDescriptor_ScheduleRelationship_Canceled:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - VehicleDescriptor

@implementation VehicleDescriptor

@dynamic id_p;
@dynamic label;
@dynamic licensePlate;

typedef struct VehicleDescriptor__storage_ {
  uint32_t _has_storage_[1];
  NSString *id_p;
  NSString *label;
  NSString *licensePlate;
} VehicleDescriptor__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = VehicleDescriptor_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(VehicleDescriptor__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "label",
        .dataTypeSpecific.className = NULL,
        .number = VehicleDescriptor_FieldNumber_Label,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(VehicleDescriptor__storage_, label),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "licensePlate",
        .dataTypeSpecific.className = NULL,
        .number = VehicleDescriptor_FieldNumber_LicensePlate,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(VehicleDescriptor__storage_, licensePlate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[VehicleDescriptor class]
                                     rootClass:[GtfsRealtimeProto3Root class]
                                          file:GtfsRealtimeProto3Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VehicleDescriptor__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EntitySelector

@implementation EntitySelector

@dynamic agencyId;
@dynamic routeId;
@dynamic routeType;
@dynamic hasTrip, trip;
@dynamic stopId;

typedef struct EntitySelector__storage_ {
  uint32_t _has_storage_[1];
  int32_t routeType;
  NSString *agencyId;
  NSString *routeId;
  TripDescriptor *trip;
  NSString *stopId;
} EntitySelector__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "agencyId",
        .dataTypeSpecific.className = NULL,
        .number = EntitySelector_FieldNumber_AgencyId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EntitySelector__storage_, agencyId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "routeId",
        .dataTypeSpecific.className = NULL,
        .number = EntitySelector_FieldNumber_RouteId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EntitySelector__storage_, routeId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "routeType",
        .dataTypeSpecific.className = NULL,
        .number = EntitySelector_FieldNumber_RouteType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(EntitySelector__storage_, routeType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "trip",
        .dataTypeSpecific.className = GPBStringifySymbol(TripDescriptor),
        .number = EntitySelector_FieldNumber_Trip,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(EntitySelector__storage_, trip),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "stopId",
        .dataTypeSpecific.className = NULL,
        .number = EntitySelector_FieldNumber_StopId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(EntitySelector__storage_, stopId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EntitySelector class]
                                     rootClass:[GtfsRealtimeProto3Root class]
                                          file:GtfsRealtimeProto3Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EntitySelector__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TranslatedString

@implementation TranslatedString

@dynamic translationArray, translationArray_Count;

typedef struct TranslatedString__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *translationArray;
} TranslatedString__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "translationArray",
        .dataTypeSpecific.className = GPBStringifySymbol(TranslatedString_Translation),
        .number = TranslatedString_FieldNumber_TranslationArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TranslatedString__storage_, translationArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TranslatedString class]
                                     rootClass:[GtfsRealtimeProto3Root class]
                                          file:GtfsRealtimeProto3Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TranslatedString__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TranslatedString_Translation

@implementation TranslatedString_Translation

@dynamic text;
@dynamic language;

typedef struct TranslatedString_Translation__storage_ {
  uint32_t _has_storage_[1];
  NSString *text;
  NSString *language;
} TranslatedString_Translation__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "text",
        .dataTypeSpecific.className = NULL,
        .number = TranslatedString_Translation_FieldNumber_Text,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TranslatedString_Translation__storage_, text),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "language",
        .dataTypeSpecific.className = NULL,
        .number = TranslatedString_Translation_FieldNumber_Language,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TranslatedString_Translation__storage_, language),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TranslatedString_Translation class]
                                     rootClass:[GtfsRealtimeProto3Root class]
                                          file:GtfsRealtimeProto3Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TranslatedString_Translation__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(TranslatedString)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
