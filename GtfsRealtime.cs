// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: gtfs-realtime.proto3
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace TransitRealtime {

  /// <summary>Holder for reflection information generated from gtfs-realtime.proto3</summary>
  public static partial class GtfsRealtimeReflection {

    #region Descriptor
    /// <summary>File descriptor for gtfs-realtime.proto3</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static GtfsRealtimeReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChRndGZzLXJlYWx0aW1lLnByb3RvMxIQdHJhbnNpdF9yZWFsdGltZSJpCgtG",
            "ZWVkTWVzc2FnZRIsCgZoZWFkZXIYASABKAsyHC50cmFuc2l0X3JlYWx0aW1l",
            "LkZlZWRIZWFkZXISLAoGZW50aXR5GAIgAygLMhwudHJhbnNpdF9yZWFsdGlt",
            "ZS5GZWVkRW50aXR5IrkBCgpGZWVkSGVhZGVyEh0KFWd0ZnNfcmVhbHRpbWVf",
            "dmVyc2lvbhgBIAEoCRJDCg5pbmNyZW1lbnRhbGl0eRgCIAEoDjIrLnRyYW5z",
            "aXRfcmVhbHRpbWUuRmVlZEhlYWRlci5JbmNyZW1lbnRhbGl0eRIRCgl0aW1l",
            "c3RhbXAYAyABKAQiNAoOSW5jcmVtZW50YWxpdHkSEAoMRlVMTF9EQVRBU0VU",
            "EAASEAoMRElGRkVSRU5USUFMEAEiuwEKCkZlZWRFbnRpdHkSCgoCaWQYASAB",
            "KAkSEgoKaXNfZGVsZXRlZBgCIAEoCBIxCgt0cmlwX3VwZGF0ZRgDIAEoCzIc",
            "LnRyYW5zaXRfcmVhbHRpbWUuVHJpcFVwZGF0ZRIyCgd2ZWhpY2xlGAQgASgL",
            "MiEudHJhbnNpdF9yZWFsdGltZS5WZWhpY2xlUG9zaXRpb24SJgoFYWxlcnQY",
            "BSABKAsyFy50cmFuc2l0X3JlYWx0aW1lLkFsZXJ0IvcECgpUcmlwVXBkYXRl",
            "Ei4KBHRyaXAYASABKAsyIC50cmFuc2l0X3JlYWx0aW1lLlRyaXBEZXNjcmlw",
            "dG9yEjQKB3ZlaGljbGUYAyABKAsyIy50cmFuc2l0X3JlYWx0aW1lLlZlaGlj",
            "bGVEZXNjcmlwdG9yEkUKEHN0b3BfdGltZV91cGRhdGUYAiADKAsyKy50cmFu",
            "c2l0X3JlYWx0aW1lLlRyaXBVcGRhdGUuU3RvcFRpbWVVcGRhdGUSEQoJdGlt",
            "ZXN0YW1wGAQgASgEEg0KBWRlbGF5GAUgASgFGkEKDVN0b3BUaW1lRXZlbnQS",
            "DQoFZGVsYXkYASABKAUSDAoEdGltZRgCIAEoAxITCgt1bmNlcnRhaW50eRgD",
            "IAEoBRrWAgoOU3RvcFRpbWVVcGRhdGUSFQoNc3RvcF9zZXF1ZW5jZRgBIAEo",
            "DRIPCgdzdG9wX2lkGAQgASgJEjsKB2Fycml2YWwYAiABKAsyKi50cmFuc2l0",
            "X3JlYWx0aW1lLlRyaXBVcGRhdGUuU3RvcFRpbWVFdmVudBI9CglkZXBhcnR1",
            "cmUYAyABKAsyKi50cmFuc2l0X3JlYWx0aW1lLlRyaXBVcGRhdGUuU3RvcFRp",
            "bWVFdmVudBJfChVzY2hlZHVsZV9yZWxhdGlvbnNoaXAYBSABKA4yQC50cmFu",
            "c2l0X3JlYWx0aW1lLlRyaXBVcGRhdGUuU3RvcFRpbWVVcGRhdGUuU2NoZWR1",
            "bGVSZWxhdGlvbnNoaXAiPwoUU2NoZWR1bGVSZWxhdGlvbnNoaXASDQoJU0NI",
            "RURVTEVEEAASCwoHU0tJUFBFRBABEgsKB05PX0RBVEEQAiLJBgoPVmVoaWNs",
            "ZVBvc2l0aW9uEi4KBHRyaXAYASABKAsyIC50cmFuc2l0X3JlYWx0aW1lLlRy",
            "aXBEZXNjcmlwdG9yEjQKB3ZlaGljbGUYCCABKAsyIy50cmFuc2l0X3JlYWx0",
            "aW1lLlZlaGljbGVEZXNjcmlwdG9yEiwKCHBvc2l0aW9uGAIgASgLMhoudHJh",
            "bnNpdF9yZWFsdGltZS5Qb3NpdGlvbhIdChVjdXJyZW50X3N0b3Bfc2VxdWVu",
            "Y2UYAyABKA0SDwoHc3RvcF9pZBgHIAEoCRJLCg5jdXJyZW50X3N0YXR1cxgE",
            "IAEoDjIzLnRyYW5zaXRfcmVhbHRpbWUuVmVoaWNsZVBvc2l0aW9uLlZlaGlj",
            "bGVTdG9wU3RhdHVzEhEKCXRpbWVzdGFtcBgFIAEoBBJLChBjb25nZXN0aW9u",
            "X2xldmVsGAYgASgOMjEudHJhbnNpdF9yZWFsdGltZS5WZWhpY2xlUG9zaXRp",
            "b24uQ29uZ2VzdGlvbkxldmVsEksKEG9jY3VwYW5jeV9zdGF0dXMYCSABKA4y",
            "MS50cmFuc2l0X3JlYWx0aW1lLlZlaGljbGVQb3NpdGlvbi5PY2N1cGFuY3lT",
            "dGF0dXMiRwoRVmVoaWNsZVN0b3BTdGF0dXMSDwoLSU5DT01JTkdfQVQQABIO",
            "CgpTVE9QUEVEX0FUEAESEQoNSU5fVFJBTlNJVF9UTxACIn0KD0Nvbmdlc3Rp",
            "b25MZXZlbBIcChhVTktOT1dOX0NPTkdFU1RJT05fTEVWRUwQABIUChBSVU5O",
            "SU5HX1NNT09USExZEAESDwoLU1RPUF9BTkRfR08QAhIOCgpDT05HRVNUSU9O",
            "EAMSFQoRU0VWRVJFX0NPTkdFU1RJT04QBCKvAQoPT2NjdXBhbmN5U3RhdHVz",
            "EgkKBUVNUFRZEAASGAoUTUFOWV9TRUFUU19BVkFJTEFCTEUQARIXChNGRVdf",
            "U0VBVFNfQVZBSUxBQkxFEAISFgoSU1RBTkRJTkdfUk9PTV9PTkxZEAMSHgoa",
            "Q1JVU0hFRF9TVEFORElOR19ST09NX09OTFkQBBIICgRGVUxMEAUSHAoYTk9U",
            "X0FDQ0VQVElOR19QQVNTRU5HRVJTEAYixAYKBUFsZXJ0EjIKDWFjdGl2ZV9w",
            "ZXJpb2QYASADKAsyGy50cmFuc2l0X3JlYWx0aW1lLlRpbWVSYW5nZRI5Cg9p",
            "bmZvcm1lZF9lbnRpdHkYBSADKAsyIC50cmFuc2l0X3JlYWx0aW1lLkVudGl0",
            "eVNlbGVjdG9yEiwKBWNhdXNlGAYgASgOMh0udHJhbnNpdF9yZWFsdGltZS5B",
            "bGVydC5DYXVzZRIuCgZlZmZlY3QYByABKA4yHi50cmFuc2l0X3JlYWx0aW1l",
            "LkFsZXJ0LkVmZmVjdBIvCgN1cmwYCCABKAsyIi50cmFuc2l0X3JlYWx0aW1l",
            "LlRyYW5zbGF0ZWRTdHJpbmcSNwoLaGVhZGVyX3RleHQYCiABKAsyIi50cmFu",
            "c2l0X3JlYWx0aW1lLlRyYW5zbGF0ZWRTdHJpbmcSPAoQZGVzY3JpcHRpb25f",
            "dGV4dBgLIAEoCzIiLnRyYW5zaXRfcmVhbHRpbWUuVHJhbnNsYXRlZFN0cmlu",
            "ZyLyAQoFQ2F1c2USGAoUUFJPVE8zX0RFRkFVTFRfQ0FVU0UQABIRCg1VTktO",
            "T1dOX0NBVVNFEAESDwoLT1RIRVJfQ0FVU0UQAhIVChFURUNITklDQUxfUFJP",
            "QkxFTRADEgoKBlNUUklLRRAEEhEKDURFTU9OU1RSQVRJT04QBRIMCghBQ0NJ",
            "REVOVBAGEgsKB0hPTElEQVkQBxILCgdXRUFUSEVSEAgSDwoLTUFJTlRFTkFO",
            "Q0UQCRIQCgxDT05TVFJVQ1RJT04QChITCg9QT0xJQ0VfQUNUSVZJVFkQCxIV",
            "ChFNRURJQ0FMX0VNRVJHRU5DWRAMItABCgZFZmZlY3QSGQoVUFJPVE8zX0RF",
            "RkFVTFRfRUZGRUNUEAASDgoKTk9fU0VSVklDRRABEhMKD1JFRFVDRURfU0VS",
            "VklDRRACEhYKElNJR05JRklDQU5UX0RFTEFZUxADEgoKBkRFVE9VUhAEEhYK",
            "EkFERElUSU9OQUxfU0VSVklDRRAFEhQKEE1PRElGSUVEX1NFUlZJQ0UQBhIQ",
            "CgxPVEhFUl9FRkZFQ1QQBxISCg5VTktOT1dOX0VGRkVDVBAIEg4KClNUT1Bf",
            "TU9WRUQQCSInCglUaW1lUmFuZ2USDQoFc3RhcnQYASABKAQSCwoDZW5kGAIg",
            "ASgEImEKCFBvc2l0aW9uEhAKCGxhdGl0dWRlGAEgASgCEhEKCWxvbmdpdHVk",
            "ZRgCIAEoAhIPCgdiZWFyaW5nGAMgASgCEhAKCG9kb21ldGVyGAQgASgBEg0K",
            "BXNwZWVkGAUgASgCIpgCCg5UcmlwRGVzY3JpcHRvchIPCgd0cmlwX2lkGAEg",
            "ASgJEhAKCHJvdXRlX2lkGAUgASgJEhQKDGRpcmVjdGlvbl9pZBgGIAEoDRIS",
            "CgpzdGFydF90aW1lGAIgASgJEhIKCnN0YXJ0X2RhdGUYAyABKAkSVAoVc2No",
            "ZWR1bGVfcmVsYXRpb25zaGlwGAQgASgOMjUudHJhbnNpdF9yZWFsdGltZS5U",
            "cmlwRGVzY3JpcHRvci5TY2hlZHVsZVJlbGF0aW9uc2hpcCJPChRTY2hlZHVs",
            "ZVJlbGF0aW9uc2hpcBINCglTQ0hFRFVMRUQQABIJCgVBRERFRBABEg8KC1VO",
            "U0NIRURVTEVEEAISDAoIQ0FOQ0VMRUQQAyJFChFWZWhpY2xlRGVzY3JpcHRv",
            "chIKCgJpZBgBIAEoCRINCgVsYWJlbBgCIAEoCRIVCg1saWNlbnNlX3BsYXRl",
            "GAMgASgJIooBCg5FbnRpdHlTZWxlY3RvchIRCglhZ2VuY3lfaWQYASABKAkS",
            "EAoIcm91dGVfaWQYAiABKAkSEgoKcm91dGVfdHlwZRgDIAEoBRIuCgR0cmlw",
            "GAQgASgLMiAudHJhbnNpdF9yZWFsdGltZS5UcmlwRGVzY3JpcHRvchIPCgdz",
            "dG9wX2lkGAUgASgJIoYBChBUcmFuc2xhdGVkU3RyaW5nEkMKC3RyYW5zbGF0",
            "aW9uGAEgAygLMi4udHJhbnNpdF9yZWFsdGltZS5UcmFuc2xhdGVkU3RyaW5n",
            "LlRyYW5zbGF0aW9uGi0KC1RyYW5zbGF0aW9uEgwKBHRleHQYASABKAkSEAoI",
            "bGFuZ3VhZ2UYAiABKAlCHQobY29tLmdvb2dsZS50cmFuc2l0LnJlYWx0aW1l",
            "YgZwcm90bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { },
          new pbr::GeneratedClrTypeInfo(null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::TransitRealtime.FeedMessage), global::TransitRealtime.FeedMessage.Parser, new[]{ "Header", "Entity" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::TransitRealtime.FeedHeader), global::TransitRealtime.FeedHeader.Parser, new[]{ "GtfsRealtimeVersion", "Incrementality", "Timestamp" }, null, new[]{ typeof(global::TransitRealtime.FeedHeader.Types.Incrementality) }, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::TransitRealtime.FeedEntity), global::TransitRealtime.FeedEntity.Parser, new[]{ "Id", "IsDeleted", "TripUpdate", "Vehicle", "Alert" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::TransitRealtime.TripUpdate), global::TransitRealtime.TripUpdate.Parser, new[]{ "Trip", "Vehicle", "StopTimeUpdate", "Timestamp", "Delay" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::TransitRealtime.TripUpdate.Types.StopTimeEvent), global::TransitRealtime.TripUpdate.Types.StopTimeEvent.Parser, new[]{ "Delay", "Time", "Uncertainty" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::TransitRealtime.TripUpdate.Types.StopTimeUpdate), global::TransitRealtime.TripUpdate.Types.StopTimeUpdate.Parser, new[]{ "StopSequence", "StopId", "Arrival", "Departure", "ScheduleRelationship" }, null, new[]{ typeof(global::TransitRealtime.TripUpdate.Types.StopTimeUpdate.Types.ScheduleRelationship) }, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::TransitRealtime.VehiclePosition), global::TransitRealtime.VehiclePosition.Parser, new[]{ "Trip", "Vehicle", "Position", "CurrentStopSequence", "StopId", "CurrentStatus", "Timestamp", "CongestionLevel", "OccupancyStatus" }, null, new[]{ typeof(global::TransitRealtime.VehiclePosition.Types.VehicleStopStatus), typeof(global::TransitRealtime.VehiclePosition.Types.CongestionLevel), typeof(global::TransitRealtime.VehiclePosition.Types.OccupancyStatus) }, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::TransitRealtime.Alert), global::TransitRealtime.Alert.Parser, new[]{ "ActivePeriod", "InformedEntity", "Cause", "Effect", "Url", "HeaderText", "DescriptionText" }, null, new[]{ typeof(global::TransitRealtime.Alert.Types.Cause), typeof(global::TransitRealtime.Alert.Types.Effect) }, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::TransitRealtime.TimeRange), global::TransitRealtime.TimeRange.Parser, new[]{ "Start", "End" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::TransitRealtime.Position), global::TransitRealtime.Position.Parser, new[]{ "Latitude", "Longitude", "Bearing", "Odometer", "Speed" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::TransitRealtime.TripDescriptor), global::TransitRealtime.TripDescriptor.Parser, new[]{ "TripId", "RouteId", "DirectionId", "StartTime", "StartDate", "ScheduleRelationship" }, null, new[]{ typeof(global::TransitRealtime.TripDescriptor.Types.ScheduleRelationship) }, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::TransitRealtime.VehicleDescriptor), global::TransitRealtime.VehicleDescriptor.Parser, new[]{ "Id", "Label", "LicensePlate" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::TransitRealtime.EntitySelector), global::TransitRealtime.EntitySelector.Parser, new[]{ "AgencyId", "RouteId", "RouteType", "Trip", "StopId" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::TransitRealtime.TranslatedString), global::TransitRealtime.TranslatedString.Parser, new[]{ "Translation" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::TransitRealtime.TranslatedString.Types.Translation), global::TransitRealtime.TranslatedString.Types.Translation.Parser, new[]{ "Text", "Language" }, null, null, null)})
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  ///  The contents of a feed message.
  ///  A feed is a continuous stream of feed messages. Each message in the stream is
  ///  obtained as a response to an appropriate HTTP GET request.
  ///  A realtime feed is always defined with relation to an existing GTFS feed.
  ///  All the entity ids are resolved with respect to the GTFS feed.
  ///
  ///  A feed depends on some external configuration:
  ///  - The corresponding GTFS feed.
  ///  - Feed application (updates, positions or alerts). A feed should contain only
  ///    items of one specified application; all the other entities will be ignored.
  ///  - Polling frequency
  /// </summary>
  public sealed partial class FeedMessage : pb::IMessage<FeedMessage> {
    private static readonly pb::MessageParser<FeedMessage> _parser = new pb::MessageParser<FeedMessage>(() => new FeedMessage());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<FeedMessage> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::TransitRealtime.GtfsRealtimeReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FeedMessage() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FeedMessage(FeedMessage other) : this() {
      Header = other.header_ != null ? other.Header.Clone() : null;
      entity_ = other.entity_.Clone();
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FeedMessage Clone() {
      return new FeedMessage(this);
    }

    /// <summary>Field number for the "header" field.</summary>
    public const int HeaderFieldNumber = 1;
    private global::TransitRealtime.FeedHeader header_;
    /// <summary>
    ///  Metadata about this feed and feed message.
    ///  required FeedHeader header = 1;
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::TransitRealtime.FeedHeader Header {
      get { return header_; }
      set {
        header_ = value;
      }
    }

    /// <summary>Field number for the "entity" field.</summary>
    public const int EntityFieldNumber = 2;
    private static readonly pb::FieldCodec<global::TransitRealtime.FeedEntity> _repeated_entity_codec
        = pb::FieldCodec.ForMessage(18, global::TransitRealtime.FeedEntity.Parser);
    private readonly pbc::RepeatedField<global::TransitRealtime.FeedEntity> entity_ = new pbc::RepeatedField<global::TransitRealtime.FeedEntity>();
    /// <summary>
    ///  Contents of the feed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::TransitRealtime.FeedEntity> Entity {
      get { return entity_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as FeedMessage);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(FeedMessage other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Header, other.Header)) return false;
      if(!entity_.Equals(other.entity_)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (header_ != null) hash ^= Header.GetHashCode();
      hash ^= entity_.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (header_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Header);
      }
      entity_.WriteTo(output, _repeated_entity_codec);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (header_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Header);
      }
      size += entity_.CalculateSize(_repeated_entity_codec);
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(FeedMessage other) {
      if (other == null) {
        return;
      }
      if (other.header_ != null) {
        if (header_ == null) {
          header_ = new global::TransitRealtime.FeedHeader();
        }
        Header.MergeFrom(other.Header);
      }
      entity_.Add(other.entity_);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            if (header_ == null) {
              header_ = new global::TransitRealtime.FeedHeader();
            }
            input.ReadMessage(header_);
            break;
          }
          case 18: {
            entity_.AddEntriesFrom(input, _repeated_entity_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///  Metadata about a feed, included in feed messages.
  /// </summary>
  public sealed partial class FeedHeader : pb::IMessage<FeedHeader> {
    private static readonly pb::MessageParser<FeedHeader> _parser = new pb::MessageParser<FeedHeader>(() => new FeedHeader());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<FeedHeader> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::TransitRealtime.GtfsRealtimeReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FeedHeader() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FeedHeader(FeedHeader other) : this() {
      gtfsRealtimeVersion_ = other.gtfsRealtimeVersion_;
      incrementality_ = other.incrementality_;
      timestamp_ = other.timestamp_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FeedHeader Clone() {
      return new FeedHeader(this);
    }

    /// <summary>Field number for the "gtfs_realtime_version" field.</summary>
    public const int GtfsRealtimeVersionFieldNumber = 1;
    private string gtfsRealtimeVersion_ = "";
    /// <summary>
    ///  Version of the feed specification.
    ///  The current version is 1.0.
    ///  required string gtfs_realtime_version = 1;
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string GtfsRealtimeVersion {
      get { return gtfsRealtimeVersion_; }
      set {
        gtfsRealtimeVersion_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "incrementality" field.</summary>
    public const int IncrementalityFieldNumber = 2;
    private global::TransitRealtime.FeedHeader.Types.Incrementality incrementality_ = 0;
    /// <summary>
    ///  optional Incrementality incrementality = 2 [default = FULL_DATASET];
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::TransitRealtime.FeedHeader.Types.Incrementality Incrementality {
      get { return incrementality_; }
      set {
        incrementality_ = value;
      }
    }

    /// <summary>Field number for the "timestamp" field.</summary>
    public const int TimestampFieldNumber = 3;
    private ulong timestamp_;
    /// <summary>
    ///  This timestamp identifies the moment when the content of this feed has been
    ///  created (in server time). In POSIX time (i.e., number of seconds since
    ///  January 1st 1970 00:00:00 UTC).
    ///  optional uint64 timestamp = 3;
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong Timestamp {
      get { return timestamp_; }
      set {
        timestamp_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as FeedHeader);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(FeedHeader other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (GtfsRealtimeVersion != other.GtfsRealtimeVersion) return false;
      if (Incrementality != other.Incrementality) return false;
      if (Timestamp != other.Timestamp) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (GtfsRealtimeVersion.Length != 0) hash ^= GtfsRealtimeVersion.GetHashCode();
      if (Incrementality != 0) hash ^= Incrementality.GetHashCode();
      if (Timestamp != 0UL) hash ^= Timestamp.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (GtfsRealtimeVersion.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(GtfsRealtimeVersion);
      }
      if (Incrementality != 0) {
        output.WriteRawTag(16);
        output.WriteEnum((int) Incrementality);
      }
      if (Timestamp != 0UL) {
        output.WriteRawTag(24);
        output.WriteUInt64(Timestamp);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (GtfsRealtimeVersion.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(GtfsRealtimeVersion);
      }
      if (Incrementality != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Incrementality);
      }
      if (Timestamp != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(Timestamp);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(FeedHeader other) {
      if (other == null) {
        return;
      }
      if (other.GtfsRealtimeVersion.Length != 0) {
        GtfsRealtimeVersion = other.GtfsRealtimeVersion;
      }
      if (other.Incrementality != 0) {
        Incrementality = other.Incrementality;
      }
      if (other.Timestamp != 0UL) {
        Timestamp = other.Timestamp;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            GtfsRealtimeVersion = input.ReadString();
            break;
          }
          case 16: {
            incrementality_ = (global::TransitRealtime.FeedHeader.Types.Incrementality) input.ReadEnum();
            break;
          }
          case 24: {
            Timestamp = input.ReadUInt64();
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the FeedHeader message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      ///  Determines whether the current fetch is incremental.  Currently,
      ///  DIFFERENTIAL mode is unsupported and behavior is unspecified for feeds
      ///  that use this mode.  There are discussions on the GTFS-realtime mailing
      ///  list around fully specifying the behavior of DIFFERENTIAL mode and the
      ///  documentation will be updated when those discussions are finalized.
      /// </summary>
      public enum Incrementality {
        [pbr::OriginalName("FULL_DATASET")] FullDataset = 0,
        [pbr::OriginalName("DIFFERENTIAL")] Differential = 1,
      }

    }
    #endregion

  }

  /// <summary>
  ///  A definition (or update) of an entity in the transit feed.
  /// </summary>
  public sealed partial class FeedEntity : pb::IMessage<FeedEntity> {
    private static readonly pb::MessageParser<FeedEntity> _parser = new pb::MessageParser<FeedEntity>(() => new FeedEntity());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<FeedEntity> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::TransitRealtime.GtfsRealtimeReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FeedEntity() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FeedEntity(FeedEntity other) : this() {
      id_ = other.id_;
      isDeleted_ = other.isDeleted_;
      TripUpdate = other.tripUpdate_ != null ? other.TripUpdate.Clone() : null;
      Vehicle = other.vehicle_ != null ? other.Vehicle.Clone() : null;
      Alert = other.alert_ != null ? other.Alert.Clone() : null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FeedEntity Clone() {
      return new FeedEntity(this);
    }

    /// <summary>Field number for the "id" field.</summary>
    public const int IdFieldNumber = 1;
    private string id_ = "";
    /// <summary>
    ///  The ids are used only to provide incrementality support. The id should be
    ///  unique within a FeedMessage. Consequent FeedMessages may contain
    ///  FeedEntities with the same id. In case of a DIFFERENTIAL update the new
    ///  FeedEntity with some id will replace the old FeedEntity with the same id
    ///  (or delete it - see is_deleted below).
    ///  The actual GTFS entities (e.g. stations, routes, trips) referenced by the
    ///  feed must be specified by explicit selectors (see EntitySelector below for
    ///  more info).
    ///  required string id = 1;
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Id {
      get { return id_; }
      set {
        id_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "is_deleted" field.</summary>
    public const int IsDeletedFieldNumber = 2;
    private bool isDeleted_;
    /// <summary>
    ///  Whether this entity is to be deleted. Relevant only for incremental
    ///  fetches.
    ///  optional bool is_deleted = 2 [default = false];
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsDeleted {
      get { return isDeleted_; }
      set {
        isDeleted_ = value;
      }
    }

    /// <summary>Field number for the "trip_update" field.</summary>
    public const int TripUpdateFieldNumber = 3;
    private global::TransitRealtime.TripUpdate tripUpdate_;
    /// <summary>
    ///  Data about the entity itself. Exactly one of the following fields must be
    ///  present (unless the entity is being deleted).
    ///  optional TripUpdate trip_update = 3;
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::TransitRealtime.TripUpdate TripUpdate {
      get { return tripUpdate_; }
      set {
        tripUpdate_ = value;
      }
    }

    /// <summary>Field number for the "vehicle" field.</summary>
    public const int VehicleFieldNumber = 4;
    private global::TransitRealtime.VehiclePosition vehicle_;
    /// <summary>
    ///  optional VehiclePosition vehicle = 4;
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::TransitRealtime.VehiclePosition Vehicle {
      get { return vehicle_; }
      set {
        vehicle_ = value;
      }
    }

    /// <summary>Field number for the "alert" field.</summary>
    public const int AlertFieldNumber = 5;
    private global::TransitRealtime.Alert alert_;
    /// <summary>
    ///  optional Alert alert = 5;
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::TransitRealtime.Alert Alert {
      get { return alert_; }
      set {
        alert_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as FeedEntity);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(FeedEntity other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Id != other.Id) return false;
      if (IsDeleted != other.IsDeleted) return false;
      if (!object.Equals(TripUpdate, other.TripUpdate)) return false;
      if (!object.Equals(Vehicle, other.Vehicle)) return false;
      if (!object.Equals(Alert, other.Alert)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Id.Length != 0) hash ^= Id.GetHashCode();
      if (IsDeleted != false) hash ^= IsDeleted.GetHashCode();
      if (tripUpdate_ != null) hash ^= TripUpdate.GetHashCode();
      if (vehicle_ != null) hash ^= Vehicle.GetHashCode();
      if (alert_ != null) hash ^= Alert.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Id.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Id);
      }
      if (IsDeleted != false) {
        output.WriteRawTag(16);
        output.WriteBool(IsDeleted);
      }
      if (tripUpdate_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(TripUpdate);
      }
      if (vehicle_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Vehicle);
      }
      if (alert_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(Alert);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Id.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Id);
      }
      if (IsDeleted != false) {
        size += 1 + 1;
      }
      if (tripUpdate_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TripUpdate);
      }
      if (vehicle_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Vehicle);
      }
      if (alert_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Alert);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(FeedEntity other) {
      if (other == null) {
        return;
      }
      if (other.Id.Length != 0) {
        Id = other.Id;
      }
      if (other.IsDeleted != false) {
        IsDeleted = other.IsDeleted;
      }
      if (other.tripUpdate_ != null) {
        if (tripUpdate_ == null) {
          tripUpdate_ = new global::TransitRealtime.TripUpdate();
        }
        TripUpdate.MergeFrom(other.TripUpdate);
      }
      if (other.vehicle_ != null) {
        if (vehicle_ == null) {
          vehicle_ = new global::TransitRealtime.VehiclePosition();
        }
        Vehicle.MergeFrom(other.Vehicle);
      }
      if (other.alert_ != null) {
        if (alert_ == null) {
          alert_ = new global::TransitRealtime.Alert();
        }
        Alert.MergeFrom(other.Alert);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            Id = input.ReadString();
            break;
          }
          case 16: {
            IsDeleted = input.ReadBool();
            break;
          }
          case 26: {
            if (tripUpdate_ == null) {
              tripUpdate_ = new global::TransitRealtime.TripUpdate();
            }
            input.ReadMessage(tripUpdate_);
            break;
          }
          case 34: {
            if (vehicle_ == null) {
              vehicle_ = new global::TransitRealtime.VehiclePosition();
            }
            input.ReadMessage(vehicle_);
            break;
          }
          case 42: {
            if (alert_ == null) {
              alert_ = new global::TransitRealtime.Alert();
            }
            input.ReadMessage(alert_);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///  Realtime update of the progress of a vehicle along a trip.
  ///  Depending on the value of ScheduleRelationship, a TripUpdate can specify:
  ///  - A trip that proceeds along the schedule.
  ///  - A trip that proceeds along a route but has no fixed schedule.
  ///  - A trip that have been added or removed with regard to schedule.
  ///
  ///  The updates can be for future, predicted arrival/departure events, or for
  ///  past events that already occurred.
  ///  Normally, updates should get more precise and more certain (see
  ///  uncertainty below) as the events gets closer to current time.
  ///  Even if that is not possible, the information for past events should be
  ///  precise and certain. In particular, if an update points to time in the past
  ///  but its update's uncertainty is not 0, the client should conclude that the
  ///  update is a (wrong) prediction and that the trip has not completed yet.
  ///
  ///  Note that the update can describe a trip that is already completed.
  ///  To this end, it is enough to provide an update for the last stop of the trip.
  ///  If the time of that is in the past, the client will conclude from that that
  ///  the whole trip is in the past (it is possible, although inconsequential, to
  ///  also provide updates for preceding stops).
  ///  This option is most relevant for a trip that has completed ahead of schedule,
  ///  but according to the schedule, the trip is still proceeding at the current
  ///  time. Removing the updates for this trip could make the client assume
  ///  that the trip is still proceeding.
  ///  Note that the feed provider is allowed, but not required, to purge past
  ///  updates - this is one case where this would be practically useful.
  /// </summary>
  public sealed partial class TripUpdate : pb::IMessage<TripUpdate> {
    private static readonly pb::MessageParser<TripUpdate> _parser = new pb::MessageParser<TripUpdate>(() => new TripUpdate());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TripUpdate> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::TransitRealtime.GtfsRealtimeReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TripUpdate() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TripUpdate(TripUpdate other) : this() {
      Trip = other.trip_ != null ? other.Trip.Clone() : null;
      Vehicle = other.vehicle_ != null ? other.Vehicle.Clone() : null;
      stopTimeUpdate_ = other.stopTimeUpdate_.Clone();
      timestamp_ = other.timestamp_;
      delay_ = other.delay_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TripUpdate Clone() {
      return new TripUpdate(this);
    }

    /// <summary>Field number for the "trip" field.</summary>
    public const int TripFieldNumber = 1;
    private global::TransitRealtime.TripDescriptor trip_;
    /// <summary>
    ///  The Trip that this message applies to. There can be at most one
    ///  TripUpdate entity for each actual trip instance.
    ///  If there is none, that means there is no prediction information available.
    ///  It does *not* mean that the trip is progressing according to schedule.
    ///  required TripDescriptor trip = 1;
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::TransitRealtime.TripDescriptor Trip {
      get { return trip_; }
      set {
        trip_ = value;
      }
    }

    /// <summary>Field number for the "vehicle" field.</summary>
    public const int VehicleFieldNumber = 3;
    private global::TransitRealtime.VehicleDescriptor vehicle_;
    /// <summary>
    ///  Additional information on the vehicle that is serving this trip.
    ///  optional VehicleDescriptor vehicle = 3;
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::TransitRealtime.VehicleDescriptor Vehicle {
      get { return vehicle_; }
      set {
        vehicle_ = value;
      }
    }

    /// <summary>Field number for the "stop_time_update" field.</summary>
    public const int StopTimeUpdateFieldNumber = 2;
    private static readonly pb::FieldCodec<global::TransitRealtime.TripUpdate.Types.StopTimeUpdate> _repeated_stopTimeUpdate_codec
        = pb::FieldCodec.ForMessage(18, global::TransitRealtime.TripUpdate.Types.StopTimeUpdate.Parser);
    private readonly pbc::RepeatedField<global::TransitRealtime.TripUpdate.Types.StopTimeUpdate> stopTimeUpdate_ = new pbc::RepeatedField<global::TransitRealtime.TripUpdate.Types.StopTimeUpdate>();
    /// <summary>
    ///  Updates to StopTimes for the trip (both future, i.e., predictions, and in
    ///  some cases, past ones, i.e., those that already happened).
    ///  The updates must be sorted by stop_sequence, and apply for all the
    ///  following stops of the trip up to the next specified one.
    ///
    ///  Example 1:
    ///  For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
    ///  delay of 0 for stop_sequence of the current stop means that the trip is
    ///  exactly on time.
    ///
    ///  Example 2:
    ///  For the same trip instance, 3 StopTimeUpdates are provided:
    ///  - delay of 5 min for stop_sequence 3
    ///  - delay of 1 min for stop_sequence 8
    ///  - delay of unspecified duration for stop_sequence 10
    ///  This will be interpreted as:
    ///  - stop_sequences 3,4,5,6,7 have delay of 5 min.
    ///  - stop_sequences 8,9 have delay of 1 min.
    ///  - stop_sequences 10,... have unknown delay.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::TransitRealtime.TripUpdate.Types.StopTimeUpdate> StopTimeUpdate {
      get { return stopTimeUpdate_; }
    }

    /// <summary>Field number for the "timestamp" field.</summary>
    public const int TimestampFieldNumber = 4;
    private ulong timestamp_;
    /// <summary>
    ///  Moment at which the vehicle's real-time progress was measured. In POSIX
    ///  time (i.e., the number of seconds since January 1st 1970 00:00:00 UTC).
    ///  optional uint64 timestamp = 4;
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong Timestamp {
      get { return timestamp_; }
      set {
        timestamp_ = value;
      }
    }

    /// <summary>Field number for the "delay" field.</summary>
    public const int DelayFieldNumber = 5;
    private int delay_;
    /// <summary>
    ///  The current schedule deviation for the trip.  Delay should only be
    ///  specified when the prediction is given relative to some existing schedule
    ///  in GTFS.
    ///
    ///  Delay (in seconds) can be positive (meaning that the vehicle is late) or
    ///  negative (meaning that the vehicle is ahead of schedule). Delay of 0
    ///  means that the vehicle is exactly on time.
    ///
    ///  Delay information in StopTimeUpdates take precedent of trip-level delay
    ///  information, such that trip-level delay is only propagated until the next
    ///  stop along the trip with a StopTimeUpdate delay value specified.
    ///
    ///  Feed providers are strongly encouraged to provide a TripUpdate.timestamp
    ///  value indicating when the delay value was last updated, in order to
    ///  evaluate the freshness of the data.
    ///
    ///  NOTE: This field is still experimental, and subject to change. It may be
    ///  formally adopted in the future.
    ///  optional int32 delay = 5;
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int Delay {
      get { return delay_; }
      set {
        delay_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TripUpdate);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TripUpdate other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Trip, other.Trip)) return false;
      if (!object.Equals(Vehicle, other.Vehicle)) return false;
      if(!stopTimeUpdate_.Equals(other.stopTimeUpdate_)) return false;
      if (Timestamp != other.Timestamp) return false;
      if (Delay != other.Delay) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (trip_ != null) hash ^= Trip.GetHashCode();
      if (vehicle_ != null) hash ^= Vehicle.GetHashCode();
      hash ^= stopTimeUpdate_.GetHashCode();
      if (Timestamp != 0UL) hash ^= Timestamp.GetHashCode();
      if (Delay != 0) hash ^= Delay.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (trip_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Trip);
      }
      stopTimeUpdate_.WriteTo(output, _repeated_stopTimeUpdate_codec);
      if (vehicle_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Vehicle);
      }
      if (Timestamp != 0UL) {
        output.WriteRawTag(32);
        output.WriteUInt64(Timestamp);
      }
      if (Delay != 0) {
        output.WriteRawTag(40);
        output.WriteInt32(Delay);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (trip_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Trip);
      }
      if (vehicle_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Vehicle);
      }
      size += stopTimeUpdate_.CalculateSize(_repeated_stopTimeUpdate_codec);
      if (Timestamp != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(Timestamp);
      }
      if (Delay != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Delay);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TripUpdate other) {
      if (other == null) {
        return;
      }
      if (other.trip_ != null) {
        if (trip_ == null) {
          trip_ = new global::TransitRealtime.TripDescriptor();
        }
        Trip.MergeFrom(other.Trip);
      }
      if (other.vehicle_ != null) {
        if (vehicle_ == null) {
          vehicle_ = new global::TransitRealtime.VehicleDescriptor();
        }
        Vehicle.MergeFrom(other.Vehicle);
      }
      stopTimeUpdate_.Add(other.stopTimeUpdate_);
      if (other.Timestamp != 0UL) {
        Timestamp = other.Timestamp;
      }
      if (other.Delay != 0) {
        Delay = other.Delay;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            if (trip_ == null) {
              trip_ = new global::TransitRealtime.TripDescriptor();
            }
            input.ReadMessage(trip_);
            break;
          }
          case 18: {
            stopTimeUpdate_.AddEntriesFrom(input, _repeated_stopTimeUpdate_codec);
            break;
          }
          case 26: {
            if (vehicle_ == null) {
              vehicle_ = new global::TransitRealtime.VehicleDescriptor();
            }
            input.ReadMessage(vehicle_);
            break;
          }
          case 32: {
            Timestamp = input.ReadUInt64();
            break;
          }
          case 40: {
            Delay = input.ReadInt32();
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the TripUpdate message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      ///  Timing information for a single predicted event (either arrival or
      ///  departure).
      ///  Timing consists of delay and/or estimated time, and uncertainty.
      ///  - delay should be used when the prediction is given relative to some
      ///    existing schedule in GTFS.
      ///  - time should be given whether there is a predicted schedule or not. If
      ///    both time and delay are specified, time will take precedence
      ///    (although normally, time, if given for a scheduled trip, should be
      ///    equal to scheduled time in GTFS + delay).
      ///
      ///  Uncertainty applies equally to both time and delay.
      ///  The uncertainty roughly specifies the expected error in true delay (but
      ///  note, we don't yet define its precise statistical meaning). It's possible
      ///  for the uncertainty to be 0, for example for trains that are driven under
      ///  computer timing control.
      /// </summary>
      public sealed partial class StopTimeEvent : pb::IMessage<StopTimeEvent> {
        private static readonly pb::MessageParser<StopTimeEvent> _parser = new pb::MessageParser<StopTimeEvent>(() => new StopTimeEvent());
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<StopTimeEvent> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::TransitRealtime.TripUpdate.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public StopTimeEvent() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public StopTimeEvent(StopTimeEvent other) : this() {
          delay_ = other.delay_;
          time_ = other.time_;
          uncertainty_ = other.uncertainty_;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public StopTimeEvent Clone() {
          return new StopTimeEvent(this);
        }

        /// <summary>Field number for the "delay" field.</summary>
        public const int DelayFieldNumber = 1;
        private int delay_;
        /// <summary>
        ///  Delay (in seconds) can be positive (meaning that the vehicle is late) or
        ///  negative (meaning that the vehicle is ahead of schedule). Delay of 0
        ///  means that the vehicle is exactly on time.
        ///  optional int32 delay = 1;
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int Delay {
          get { return delay_; }
          set {
            delay_ = value;
          }
        }

        /// <summary>Field number for the "time" field.</summary>
        public const int TimeFieldNumber = 2;
        private long time_;
        /// <summary>
        ///  Event as absolute time.
        ///  In Unix time (i.e., number of seconds since January 1st 1970 00:00:00
        ///  UTC).
        ///  optional int64 time = 2;
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public long Time {
          get { return time_; }
          set {
            time_ = value;
          }
        }

        /// <summary>Field number for the "uncertainty" field.</summary>
        public const int UncertaintyFieldNumber = 3;
        private int uncertainty_;
        /// <summary>
        ///  If uncertainty is omitted, it is interpreted as unknown.
        ///  If the prediction is unknown or too uncertain, the delay (or time) field
        ///  should be empty. In such case, the uncertainty field is ignored.
        ///  To specify a completely certain prediction, set its uncertainty to 0.
        ///  optional int32 uncertainty = 3;
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int Uncertainty {
          get { return uncertainty_; }
          set {
            uncertainty_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as StopTimeEvent);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(StopTimeEvent other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Delay != other.Delay) return false;
          if (Time != other.Time) return false;
          if (Uncertainty != other.Uncertainty) return false;
          return true;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Delay != 0) hash ^= Delay.GetHashCode();
          if (Time != 0L) hash ^= Time.GetHashCode();
          if (Uncertainty != 0) hash ^= Uncertainty.GetHashCode();
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (Delay != 0) {
            output.WriteRawTag(8);
            output.WriteInt32(Delay);
          }
          if (Time != 0L) {
            output.WriteRawTag(16);
            output.WriteInt64(Time);
          }
          if (Uncertainty != 0) {
            output.WriteRawTag(24);
            output.WriteInt32(Uncertainty);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Delay != 0) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(Delay);
          }
          if (Time != 0L) {
            size += 1 + pb::CodedOutputStream.ComputeInt64Size(Time);
          }
          if (Uncertainty != 0) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(Uncertainty);
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(StopTimeEvent other) {
          if (other == null) {
            return;
          }
          if (other.Delay != 0) {
            Delay = other.Delay;
          }
          if (other.Time != 0L) {
            Time = other.Time;
          }
          if (other.Uncertainty != 0) {
            Uncertainty = other.Uncertainty;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 8: {
                Delay = input.ReadInt32();
                break;
              }
              case 16: {
                Time = input.ReadInt64();
                break;
              }
              case 24: {
                Uncertainty = input.ReadInt32();
                break;
              }
            }
          }
        }

      }

      /// <summary>
      ///  Realtime update for arrival and/or departure events for a given stop on a
      ///  trip. Updates can be supplied for both past and future events.
      ///  The producer is allowed, although not required, to drop past events.
      /// </summary>
      public sealed partial class StopTimeUpdate : pb::IMessage<StopTimeUpdate> {
        private static readonly pb::MessageParser<StopTimeUpdate> _parser = new pb::MessageParser<StopTimeUpdate>(() => new StopTimeUpdate());
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<StopTimeUpdate> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::TransitRealtime.TripUpdate.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public StopTimeUpdate() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public StopTimeUpdate(StopTimeUpdate other) : this() {
          stopSequence_ = other.stopSequence_;
          stopId_ = other.stopId_;
          Arrival = other.arrival_ != null ? other.Arrival.Clone() : null;
          Departure = other.departure_ != null ? other.Departure.Clone() : null;
          scheduleRelationship_ = other.scheduleRelationship_;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public StopTimeUpdate Clone() {
          return new StopTimeUpdate(this);
        }

        /// <summary>Field number for the "stop_sequence" field.</summary>
        public const int StopSequenceFieldNumber = 1;
        private uint stopSequence_;
        /// <summary>
        ///  Must be the same as in stop_times.txt in the corresponding GTFS feed.
        ///  optional uint32 stop_sequence = 1;
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public uint StopSequence {
          get { return stopSequence_; }
          set {
            stopSequence_ = value;
          }
        }

        /// <summary>Field number for the "stop_id" field.</summary>
        public const int StopIdFieldNumber = 4;
        private string stopId_ = "";
        /// <summary>
        ///  Must be the same as in stops.txt in the corresponding GTFS feed.
        ///  optional string stop_id = 4;
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string StopId {
          get { return stopId_; }
          set {
            stopId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "arrival" field.</summary>
        public const int ArrivalFieldNumber = 2;
        private global::TransitRealtime.TripUpdate.Types.StopTimeEvent arrival_;
        /// <summary>
        ///  optional StopTimeEvent arrival = 2;
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::TransitRealtime.TripUpdate.Types.StopTimeEvent Arrival {
          get { return arrival_; }
          set {
            arrival_ = value;
          }
        }

        /// <summary>Field number for the "departure" field.</summary>
        public const int DepartureFieldNumber = 3;
        private global::TransitRealtime.TripUpdate.Types.StopTimeEvent departure_;
        /// <summary>
        ///  optional StopTimeEvent departure = 3;
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::TransitRealtime.TripUpdate.Types.StopTimeEvent Departure {
          get { return departure_; }
          set {
            departure_ = value;
          }
        }

        /// <summary>Field number for the "schedule_relationship" field.</summary>
        public const int ScheduleRelationshipFieldNumber = 5;
        private global::TransitRealtime.TripUpdate.Types.StopTimeUpdate.Types.ScheduleRelationship scheduleRelationship_ = 0;
        /// <summary>
        ///  optional ScheduleRelationship schedule_relationship = 5
        ///     [default = SCHEDULED];
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::TransitRealtime.TripUpdate.Types.StopTimeUpdate.Types.ScheduleRelationship ScheduleRelationship {
          get { return scheduleRelationship_; }
          set {
            scheduleRelationship_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as StopTimeUpdate);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(StopTimeUpdate other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (StopSequence != other.StopSequence) return false;
          if (StopId != other.StopId) return false;
          if (!object.Equals(Arrival, other.Arrival)) return false;
          if (!object.Equals(Departure, other.Departure)) return false;
          if (ScheduleRelationship != other.ScheduleRelationship) return false;
          return true;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (StopSequence != 0) hash ^= StopSequence.GetHashCode();
          if (StopId.Length != 0) hash ^= StopId.GetHashCode();
          if (arrival_ != null) hash ^= Arrival.GetHashCode();
          if (departure_ != null) hash ^= Departure.GetHashCode();
          if (ScheduleRelationship != 0) hash ^= ScheduleRelationship.GetHashCode();
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (StopSequence != 0) {
            output.WriteRawTag(8);
            output.WriteUInt32(StopSequence);
          }
          if (arrival_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(Arrival);
          }
          if (departure_ != null) {
            output.WriteRawTag(26);
            output.WriteMessage(Departure);
          }
          if (StopId.Length != 0) {
            output.WriteRawTag(34);
            output.WriteString(StopId);
          }
          if (ScheduleRelationship != 0) {
            output.WriteRawTag(40);
            output.WriteEnum((int) ScheduleRelationship);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (StopSequence != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(StopSequence);
          }
          if (StopId.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(StopId);
          }
          if (arrival_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Arrival);
          }
          if (departure_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Departure);
          }
          if (ScheduleRelationship != 0) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ScheduleRelationship);
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(StopTimeUpdate other) {
          if (other == null) {
            return;
          }
          if (other.StopSequence != 0) {
            StopSequence = other.StopSequence;
          }
          if (other.StopId.Length != 0) {
            StopId = other.StopId;
          }
          if (other.arrival_ != null) {
            if (arrival_ == null) {
              arrival_ = new global::TransitRealtime.TripUpdate.Types.StopTimeEvent();
            }
            Arrival.MergeFrom(other.Arrival);
          }
          if (other.departure_ != null) {
            if (departure_ == null) {
              departure_ = new global::TransitRealtime.TripUpdate.Types.StopTimeEvent();
            }
            Departure.MergeFrom(other.Departure);
          }
          if (other.ScheduleRelationship != 0) {
            ScheduleRelationship = other.ScheduleRelationship;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 8: {
                StopSequence = input.ReadUInt32();
                break;
              }
              case 18: {
                if (arrival_ == null) {
                  arrival_ = new global::TransitRealtime.TripUpdate.Types.StopTimeEvent();
                }
                input.ReadMessage(arrival_);
                break;
              }
              case 26: {
                if (departure_ == null) {
                  departure_ = new global::TransitRealtime.TripUpdate.Types.StopTimeEvent();
                }
                input.ReadMessage(departure_);
                break;
              }
              case 34: {
                StopId = input.ReadString();
                break;
              }
              case 40: {
                scheduleRelationship_ = (global::TransitRealtime.TripUpdate.Types.StopTimeUpdate.Types.ScheduleRelationship) input.ReadEnum();
                break;
              }
            }
          }
        }

        #region Nested types
        /// <summary>Container for nested types declared in the StopTimeUpdate message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static partial class Types {
          /// <summary>
          ///  The relation between this StopTime and the static schedule.
          /// </summary>
          public enum ScheduleRelationship {
            /// <summary>
            ///  The vehicle is proceeding in accordance with its static schedule of
            ///  stops, although not necessarily according to the times of the schedule.
            ///  At least one of arrival and departure must be provided. If the schedule
            ///  for this stop contains both arrival and departure times then so must
            ///  this update.
            /// </summary>
            [pbr::OriginalName("SCHEDULED")] Scheduled = 0,
            /// <summary>
            ///  The stop is skipped, i.e., the vehicle will not stop at this stop.
            ///  Arrival and departure are // optional.
            /// </summary>
            [pbr::OriginalName("SKIPPED")] Skipped = 1,
            /// <summary>
            ///  No data is given for this stop. The main intention for this value is to
            ///  give the predictions only for part of a trip, i.e., if the last update
            ///  for a trip has a NO_DATA specifier, then StopTimes for the rest of the
            ///  stops in the trip are considered to be unspecified as well.
            ///  Neither arrival nor departure should be supplied.
            /// </summary>
            [pbr::OriginalName("NO_DATA")] NoData = 2,
          }

        }
        #endregion

      }

    }
    #endregion

  }

  /// <summary>
  ///  Realtime positioning information for a given vehicle.
  /// </summary>
  public sealed partial class VehiclePosition : pb::IMessage<VehiclePosition> {
    private static readonly pb::MessageParser<VehiclePosition> _parser = new pb::MessageParser<VehiclePosition>(() => new VehiclePosition());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<VehiclePosition> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::TransitRealtime.GtfsRealtimeReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public VehiclePosition() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public VehiclePosition(VehiclePosition other) : this() {
      Trip = other.trip_ != null ? other.Trip.Clone() : null;
      Vehicle = other.vehicle_ != null ? other.Vehicle.Clone() : null;
      Position = other.position_ != null ? other.Position.Clone() : null;
      currentStopSequence_ = other.currentStopSequence_;
      stopId_ = other.stopId_;
      currentStatus_ = other.currentStatus_;
      timestamp_ = other.timestamp_;
      congestionLevel_ = other.congestionLevel_;
      occupancyStatus_ = other.occupancyStatus_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public VehiclePosition Clone() {
      return new VehiclePosition(this);
    }

    /// <summary>Field number for the "trip" field.</summary>
    public const int TripFieldNumber = 1;
    private global::TransitRealtime.TripDescriptor trip_;
    /// <summary>
    ///  The Trip that this vehicle is serving.
    ///  Can be empty or partial if the vehicle can not be identified with a given
    ///  trip instance.
    ///  optional TripDescriptor trip = 1;
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::TransitRealtime.TripDescriptor Trip {
      get { return trip_; }
      set {
        trip_ = value;
      }
    }

    /// <summary>Field number for the "vehicle" field.</summary>
    public const int VehicleFieldNumber = 8;
    private global::TransitRealtime.VehicleDescriptor vehicle_;
    /// <summary>
    ///  Additional information on the vehicle that is serving this trip.
    ///  optional VehicleDescriptor vehicle = 8;
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::TransitRealtime.VehicleDescriptor Vehicle {
      get { return vehicle_; }
      set {
        vehicle_ = value;
      }
    }

    /// <summary>Field number for the "position" field.</summary>
    public const int PositionFieldNumber = 2;
    private global::TransitRealtime.Position position_;
    /// <summary>
    ///  Current position of this vehicle.
    ///  optional Position position = 2;
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::TransitRealtime.Position Position {
      get { return position_; }
      set {
        position_ = value;
      }
    }

    /// <summary>Field number for the "current_stop_sequence" field.</summary>
    public const int CurrentStopSequenceFieldNumber = 3;
    private uint currentStopSequence_;
    /// <summary>
    ///  The stop sequence index of the current stop. The meaning of
    ///  current_stop_sequence (i.e., the stop that it refers to) is determined by
    ///  current_status.
    ///  If current_status is missing IN_TRANSIT_TO is assumed.
    ///  optional uint32 current_stop_sequence = 3;
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint CurrentStopSequence {
      get { return currentStopSequence_; }
      set {
        currentStopSequence_ = value;
      }
    }

    /// <summary>Field number for the "stop_id" field.</summary>
    public const int StopIdFieldNumber = 7;
    private string stopId_ = "";
    /// <summary>
    ///  Identifies the current stop. The value must be the same as in stops.txt in
    ///  the corresponding GTFS feed.
    ///  optional string stop_id = 7;
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string StopId {
      get { return stopId_; }
      set {
        stopId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "current_status" field.</summary>
    public const int CurrentStatusFieldNumber = 4;
    private global::TransitRealtime.VehiclePosition.Types.VehicleStopStatus currentStatus_ = 0;
    /// <summary>
    ///  The exact status of the vehicle with respect to the current stop.
    ///  Ignored if current_stop_sequence is missing.
    ///  optional VehicleStopStatus current_status = 4 [default = IN_TRANSIT_TO];
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::TransitRealtime.VehiclePosition.Types.VehicleStopStatus CurrentStatus {
      get { return currentStatus_; }
      set {
        currentStatus_ = value;
      }
    }

    /// <summary>Field number for the "timestamp" field.</summary>
    public const int TimestampFieldNumber = 5;
    private ulong timestamp_;
    /// <summary>
    ///  Moment at which the vehicle's position was measured. In POSIX time
    ///  (i.e., number of seconds since January 1st 1970 00:00:00 UTC).
    ///  optional uint64 timestamp = 5;
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong Timestamp {
      get { return timestamp_; }
      set {
        timestamp_ = value;
      }
    }

    /// <summary>Field number for the "congestion_level" field.</summary>
    public const int CongestionLevelFieldNumber = 6;
    private global::TransitRealtime.VehiclePosition.Types.CongestionLevel congestionLevel_ = 0;
    /// <summary>
    ///  optional CongestionLevel congestion_level = 6;
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::TransitRealtime.VehiclePosition.Types.CongestionLevel CongestionLevel {
      get { return congestionLevel_; }
      set {
        congestionLevel_ = value;
      }
    }

    /// <summary>Field number for the "occupancy_status" field.</summary>
    public const int OccupancyStatusFieldNumber = 9;
    private global::TransitRealtime.VehiclePosition.Types.OccupancyStatus occupancyStatus_ = 0;
    /// <summary>
    ///  optional OccupancyStatus occupancy_status = 9;
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::TransitRealtime.VehiclePosition.Types.OccupancyStatus OccupancyStatus {
      get { return occupancyStatus_; }
      set {
        occupancyStatus_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as VehiclePosition);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(VehiclePosition other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Trip, other.Trip)) return false;
      if (!object.Equals(Vehicle, other.Vehicle)) return false;
      if (!object.Equals(Position, other.Position)) return false;
      if (CurrentStopSequence != other.CurrentStopSequence) return false;
      if (StopId != other.StopId) return false;
      if (CurrentStatus != other.CurrentStatus) return false;
      if (Timestamp != other.Timestamp) return false;
      if (CongestionLevel != other.CongestionLevel) return false;
      if (OccupancyStatus != other.OccupancyStatus) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (trip_ != null) hash ^= Trip.GetHashCode();
      if (vehicle_ != null) hash ^= Vehicle.GetHashCode();
      if (position_ != null) hash ^= Position.GetHashCode();
      if (CurrentStopSequence != 0) hash ^= CurrentStopSequence.GetHashCode();
      if (StopId.Length != 0) hash ^= StopId.GetHashCode();
      if (CurrentStatus != 0) hash ^= CurrentStatus.GetHashCode();
      if (Timestamp != 0UL) hash ^= Timestamp.GetHashCode();
      if (CongestionLevel != 0) hash ^= CongestionLevel.GetHashCode();
      if (OccupancyStatus != 0) hash ^= OccupancyStatus.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (trip_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Trip);
      }
      if (position_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Position);
      }
      if (CurrentStopSequence != 0) {
        output.WriteRawTag(24);
        output.WriteUInt32(CurrentStopSequence);
      }
      if (CurrentStatus != 0) {
        output.WriteRawTag(32);
        output.WriteEnum((int) CurrentStatus);
      }
      if (Timestamp != 0UL) {
        output.WriteRawTag(40);
        output.WriteUInt64(Timestamp);
      }
      if (CongestionLevel != 0) {
        output.WriteRawTag(48);
        output.WriteEnum((int) CongestionLevel);
      }
      if (StopId.Length != 0) {
        output.WriteRawTag(58);
        output.WriteString(StopId);
      }
      if (vehicle_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(Vehicle);
      }
      if (OccupancyStatus != 0) {
        output.WriteRawTag(72);
        output.WriteEnum((int) OccupancyStatus);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (trip_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Trip);
      }
      if (vehicle_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Vehicle);
      }
      if (position_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Position);
      }
      if (CurrentStopSequence != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(CurrentStopSequence);
      }
      if (StopId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(StopId);
      }
      if (CurrentStatus != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) CurrentStatus);
      }
      if (Timestamp != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(Timestamp);
      }
      if (CongestionLevel != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) CongestionLevel);
      }
      if (OccupancyStatus != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) OccupancyStatus);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(VehiclePosition other) {
      if (other == null) {
        return;
      }
      if (other.trip_ != null) {
        if (trip_ == null) {
          trip_ = new global::TransitRealtime.TripDescriptor();
        }
        Trip.MergeFrom(other.Trip);
      }
      if (other.vehicle_ != null) {
        if (vehicle_ == null) {
          vehicle_ = new global::TransitRealtime.VehicleDescriptor();
        }
        Vehicle.MergeFrom(other.Vehicle);
      }
      if (other.position_ != null) {
        if (position_ == null) {
          position_ = new global::TransitRealtime.Position();
        }
        Position.MergeFrom(other.Position);
      }
      if (other.CurrentStopSequence != 0) {
        CurrentStopSequence = other.CurrentStopSequence;
      }
      if (other.StopId.Length != 0) {
        StopId = other.StopId;
      }
      if (other.CurrentStatus != 0) {
        CurrentStatus = other.CurrentStatus;
      }
      if (other.Timestamp != 0UL) {
        Timestamp = other.Timestamp;
      }
      if (other.CongestionLevel != 0) {
        CongestionLevel = other.CongestionLevel;
      }
      if (other.OccupancyStatus != 0) {
        OccupancyStatus = other.OccupancyStatus;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            if (trip_ == null) {
              trip_ = new global::TransitRealtime.TripDescriptor();
            }
            input.ReadMessage(trip_);
            break;
          }
          case 18: {
            if (position_ == null) {
              position_ = new global::TransitRealtime.Position();
            }
            input.ReadMessage(position_);
            break;
          }
          case 24: {
            CurrentStopSequence = input.ReadUInt32();
            break;
          }
          case 32: {
            currentStatus_ = (global::TransitRealtime.VehiclePosition.Types.VehicleStopStatus) input.ReadEnum();
            break;
          }
          case 40: {
            Timestamp = input.ReadUInt64();
            break;
          }
          case 48: {
            congestionLevel_ = (global::TransitRealtime.VehiclePosition.Types.CongestionLevel) input.ReadEnum();
            break;
          }
          case 58: {
            StopId = input.ReadString();
            break;
          }
          case 66: {
            if (vehicle_ == null) {
              vehicle_ = new global::TransitRealtime.VehicleDescriptor();
            }
            input.ReadMessage(vehicle_);
            break;
          }
          case 72: {
            occupancyStatus_ = (global::TransitRealtime.VehiclePosition.Types.OccupancyStatus) input.ReadEnum();
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the VehiclePosition message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public enum VehicleStopStatus {
        /// <summary>
        ///  The vehicle is just about to arrive at the stop (on a stop
        ///  display, the vehicle symbol typically flashes).
        /// </summary>
        [pbr::OriginalName("INCOMING_AT")] IncomingAt = 0,
        /// <summary>
        ///  The vehicle is standing at the stop.
        /// </summary>
        [pbr::OriginalName("STOPPED_AT")] StoppedAt = 1,
        /// <summary>
        ///  The vehicle has departed and is in transit to the next stop.
        /// </summary>
        [pbr::OriginalName("IN_TRANSIT_TO")] InTransitTo = 2,
      }

      /// <summary>
      ///  Congestion level that is affecting this vehicle.
      /// </summary>
      public enum CongestionLevel {
        [pbr::OriginalName("UNKNOWN_CONGESTION_LEVEL")] UnknownCongestionLevel = 0,
        [pbr::OriginalName("RUNNING_SMOOTHLY")] RunningSmoothly = 1,
        [pbr::OriginalName("STOP_AND_GO")] StopAndGo = 2,
        [pbr::OriginalName("CONGESTION")] Congestion = 3,
        /// <summary>
        ///  People leaving their cars.
        /// </summary>
        [pbr::OriginalName("SEVERE_CONGESTION")] SevereCongestion = 4,
      }

      /// <summary>
      ///  The degree of passenger occupancy of the vehicle. This field is still
      ///  experimental, and subject to change. It may be formally adopted in the
      ///  future.
      /// </summary>
      public enum OccupancyStatus {
        /// <summary>
        ///  The vehicle is considered empty by most measures, and has few or no
        ///  passengers onboard, but is still accepting passengers.
        /// </summary>
        [pbr::OriginalName("EMPTY")] Empty = 0,
        /// <summary>
        ///  The vehicle has a relatively large percentage of seats available.
        ///  What percentage of free seats out of the total seats available is to be
        ///  considered large enough to fall into this category is determined at the
        ///  discretion of the producer.
        /// </summary>
        [pbr::OriginalName("MANY_SEATS_AVAILABLE")] ManySeatsAvailable = 1,
        /// <summary>
        ///  The vehicle has a relatively small percentage of seats available.
        ///  What percentage of free seats out of the total seats available is to be
        ///  considered small enough to fall into this category is determined at the
        ///  discretion of the feed producer.
        /// </summary>
        [pbr::OriginalName("FEW_SEATS_AVAILABLE")] FewSeatsAvailable = 2,
        /// <summary>
        ///  The vehicle can currently accommodate only standing passengers.
        /// </summary>
        [pbr::OriginalName("STANDING_ROOM_ONLY")] StandingRoomOnly = 3,
        /// <summary>
        ///  The vehicle can currently accommodate only standing passengers
        ///  and has limited space for them.
        /// </summary>
        [pbr::OriginalName("CRUSHED_STANDING_ROOM_ONLY")] CrushedStandingRoomOnly = 4,
        /// <summary>
        ///  The vehicle is considered full by most measures, but may still be
        ///  allowing passengers to board.
        /// </summary>
        [pbr::OriginalName("FULL")] Full = 5,
        /// <summary>
        ///  The vehicle is not accepting additional passengers.
        /// </summary>
        [pbr::OriginalName("NOT_ACCEPTING_PASSENGERS")] NotAcceptingPassengers = 6,
      }

    }
    #endregion

  }

  /// <summary>
  ///  An alert, indicating some sort of incident in the public transit network.
  /// </summary>
  public sealed partial class Alert : pb::IMessage<Alert> {
    private static readonly pb::MessageParser<Alert> _parser = new pb::MessageParser<Alert>(() => new Alert());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Alert> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::TransitRealtime.GtfsRealtimeReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Alert() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Alert(Alert other) : this() {
      activePeriod_ = other.activePeriod_.Clone();
      informedEntity_ = other.informedEntity_.Clone();
      cause_ = other.cause_;
      effect_ = other.effect_;
      Url = other.url_ != null ? other.Url.Clone() : null;
      HeaderText = other.headerText_ != null ? other.HeaderText.Clone() : null;
      DescriptionText = other.descriptionText_ != null ? other.DescriptionText.Clone() : null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Alert Clone() {
      return new Alert(this);
    }

    /// <summary>Field number for the "active_period" field.</summary>
    public const int ActivePeriodFieldNumber = 1;
    private static readonly pb::FieldCodec<global::TransitRealtime.TimeRange> _repeated_activePeriod_codec
        = pb::FieldCodec.ForMessage(10, global::TransitRealtime.TimeRange.Parser);
    private readonly pbc::RepeatedField<global::TransitRealtime.TimeRange> activePeriod_ = new pbc::RepeatedField<global::TransitRealtime.TimeRange>();
    /// <summary>
    ///  Time when the alert should be shown to the user. If missing, the
    ///  alert will be shown as long as it appears in the feed.
    ///  If multiple ranges are given, the alert will be shown during all of them.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::TransitRealtime.TimeRange> ActivePeriod {
      get { return activePeriod_; }
    }

    /// <summary>Field number for the "informed_entity" field.</summary>
    public const int InformedEntityFieldNumber = 5;
    private static readonly pb::FieldCodec<global::TransitRealtime.EntitySelector> _repeated_informedEntity_codec
        = pb::FieldCodec.ForMessage(42, global::TransitRealtime.EntitySelector.Parser);
    private readonly pbc::RepeatedField<global::TransitRealtime.EntitySelector> informedEntity_ = new pbc::RepeatedField<global::TransitRealtime.EntitySelector>();
    /// <summary>
    ///  Entities whose users we should notify of this alert.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::TransitRealtime.EntitySelector> InformedEntity {
      get { return informedEntity_; }
    }

    /// <summary>Field number for the "cause" field.</summary>
    public const int CauseFieldNumber = 6;
    private global::TransitRealtime.Alert.Types.Cause cause_ = 0;
    /// <summary>
    ///  optional Cause cause = 6 [default = UNKNOWN_CAUSE];
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::TransitRealtime.Alert.Types.Cause Cause {
      get { return cause_; }
      set {
        cause_ = value;
      }
    }

    /// <summary>Field number for the "effect" field.</summary>
    public const int EffectFieldNumber = 7;
    private global::TransitRealtime.Alert.Types.Effect effect_ = 0;
    /// <summary>
    ///  optional Effect effect = 7 [default = UNKNOWN_EFFECT];
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::TransitRealtime.Alert.Types.Effect Effect {
      get { return effect_; }
      set {
        effect_ = value;
      }
    }

    /// <summary>Field number for the "url" field.</summary>
    public const int UrlFieldNumber = 8;
    private global::TransitRealtime.TranslatedString url_;
    /// <summary>
    ///  The URL which provides additional information about the alert.
    ///  optional TranslatedString url = 8;
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::TransitRealtime.TranslatedString Url {
      get { return url_; }
      set {
        url_ = value;
      }
    }

    /// <summary>Field number for the "header_text" field.</summary>
    public const int HeaderTextFieldNumber = 10;
    private global::TransitRealtime.TranslatedString headerText_;
    /// <summary>
    ///  Alert header. Contains a short summary of the alert text as plain-text.
    ///  optional TranslatedString header_text = 10;
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::TransitRealtime.TranslatedString HeaderText {
      get { return headerText_; }
      set {
        headerText_ = value;
      }
    }

    /// <summary>Field number for the "description_text" field.</summary>
    public const int DescriptionTextFieldNumber = 11;
    private global::TransitRealtime.TranslatedString descriptionText_;
    /// <summary>
    ///  Full description for the alert as plain-text. The information in the
    ///  description should add to the information of the header.
    ///  optional TranslatedString description_text = 11;
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::TransitRealtime.TranslatedString DescriptionText {
      get { return descriptionText_; }
      set {
        descriptionText_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Alert);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Alert other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!activePeriod_.Equals(other.activePeriod_)) return false;
      if(!informedEntity_.Equals(other.informedEntity_)) return false;
      if (Cause != other.Cause) return false;
      if (Effect != other.Effect) return false;
      if (!object.Equals(Url, other.Url)) return false;
      if (!object.Equals(HeaderText, other.HeaderText)) return false;
      if (!object.Equals(DescriptionText, other.DescriptionText)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= activePeriod_.GetHashCode();
      hash ^= informedEntity_.GetHashCode();
      if (Cause != 0) hash ^= Cause.GetHashCode();
      if (Effect != 0) hash ^= Effect.GetHashCode();
      if (url_ != null) hash ^= Url.GetHashCode();
      if (headerText_ != null) hash ^= HeaderText.GetHashCode();
      if (descriptionText_ != null) hash ^= DescriptionText.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      activePeriod_.WriteTo(output, _repeated_activePeriod_codec);
      informedEntity_.WriteTo(output, _repeated_informedEntity_codec);
      if (Cause != 0) {
        output.WriteRawTag(48);
        output.WriteEnum((int) Cause);
      }
      if (Effect != 0) {
        output.WriteRawTag(56);
        output.WriteEnum((int) Effect);
      }
      if (url_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(Url);
      }
      if (headerText_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(HeaderText);
      }
      if (descriptionText_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(DescriptionText);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += activePeriod_.CalculateSize(_repeated_activePeriod_codec);
      size += informedEntity_.CalculateSize(_repeated_informedEntity_codec);
      if (Cause != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Cause);
      }
      if (Effect != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Effect);
      }
      if (url_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Url);
      }
      if (headerText_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(HeaderText);
      }
      if (descriptionText_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DescriptionText);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Alert other) {
      if (other == null) {
        return;
      }
      activePeriod_.Add(other.activePeriod_);
      informedEntity_.Add(other.informedEntity_);
      if (other.Cause != 0) {
        Cause = other.Cause;
      }
      if (other.Effect != 0) {
        Effect = other.Effect;
      }
      if (other.url_ != null) {
        if (url_ == null) {
          url_ = new global::TransitRealtime.TranslatedString();
        }
        Url.MergeFrom(other.Url);
      }
      if (other.headerText_ != null) {
        if (headerText_ == null) {
          headerText_ = new global::TransitRealtime.TranslatedString();
        }
        HeaderText.MergeFrom(other.HeaderText);
      }
      if (other.descriptionText_ != null) {
        if (descriptionText_ == null) {
          descriptionText_ = new global::TransitRealtime.TranslatedString();
        }
        DescriptionText.MergeFrom(other.DescriptionText);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            activePeriod_.AddEntriesFrom(input, _repeated_activePeriod_codec);
            break;
          }
          case 42: {
            informedEntity_.AddEntriesFrom(input, _repeated_informedEntity_codec);
            break;
          }
          case 48: {
            cause_ = (global::TransitRealtime.Alert.Types.Cause) input.ReadEnum();
            break;
          }
          case 56: {
            effect_ = (global::TransitRealtime.Alert.Types.Effect) input.ReadEnum();
            break;
          }
          case 66: {
            if (url_ == null) {
              url_ = new global::TransitRealtime.TranslatedString();
            }
            input.ReadMessage(url_);
            break;
          }
          case 82: {
            if (headerText_ == null) {
              headerText_ = new global::TransitRealtime.TranslatedString();
            }
            input.ReadMessage(headerText_);
            break;
          }
          case 90: {
            if (descriptionText_ == null) {
              descriptionText_ = new global::TransitRealtime.TranslatedString();
            }
            input.ReadMessage(descriptionText_);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the Alert message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      ///  Cause of this alert.
      /// </summary>
      public enum Cause {
        [pbr::OriginalName("PROTO3_DEFAULT_CAUSE")] Proto3DefaultCause = 0,
        [pbr::OriginalName("UNKNOWN_CAUSE")] UnknownCause = 1,
        /// <summary>
        ///  Not machine-representable.
        /// </summary>
        [pbr::OriginalName("OTHER_CAUSE")] OtherCause = 2,
        [pbr::OriginalName("TECHNICAL_PROBLEM")] TechnicalProblem = 3,
        /// <summary>
        ///  Public transit agency employees stopped working.
        /// </summary>
        [pbr::OriginalName("STRIKE")] Strike = 4,
        /// <summary>
        ///  People are blocking the streets.
        /// </summary>
        [pbr::OriginalName("DEMONSTRATION")] Demonstration = 5,
        [pbr::OriginalName("ACCIDENT")] Accident = 6,
        [pbr::OriginalName("HOLIDAY")] Holiday = 7,
        [pbr::OriginalName("WEATHER")] Weather = 8,
        [pbr::OriginalName("MAINTENANCE")] Maintenance = 9,
        [pbr::OriginalName("CONSTRUCTION")] Construction = 10,
        [pbr::OriginalName("POLICE_ACTIVITY")] PoliceActivity = 11,
        [pbr::OriginalName("MEDICAL_EMERGENCY")] MedicalEmergency = 12,
      }

      /// <summary>
      ///  What is the effect of this problem on the affected entity.
      /// </summary>
      public enum Effect {
        [pbr::OriginalName("PROTO3_DEFAULT_EFFECT")] Proto3DefaultEffect = 0,
        [pbr::OriginalName("NO_SERVICE")] NoService = 1,
        [pbr::OriginalName("REDUCED_SERVICE")] ReducedService = 2,
        /// <summary>
        ///  We don't care about INsignificant delays: they are hard to detect, have
        ///  little impact on the user, and would clutter the results as they are too
        ///  frequent.
        /// </summary>
        [pbr::OriginalName("SIGNIFICANT_DELAYS")] SignificantDelays = 3,
        [pbr::OriginalName("DETOUR")] Detour = 4,
        [pbr::OriginalName("ADDITIONAL_SERVICE")] AdditionalService = 5,
        [pbr::OriginalName("MODIFIED_SERVICE")] ModifiedService = 6,
        [pbr::OriginalName("OTHER_EFFECT")] OtherEffect = 7,
        [pbr::OriginalName("UNKNOWN_EFFECT")] UnknownEffect = 8,
        [pbr::OriginalName("STOP_MOVED")] StopMoved = 9,
      }

    }
    #endregion

  }

  /// <summary>
  ///  A time interval. The interval is considered active at time 't' if 't' is
  ///  greater than or equal to the start time and less than the end time.
  /// </summary>
  public sealed partial class TimeRange : pb::IMessage<TimeRange> {
    private static readonly pb::MessageParser<TimeRange> _parser = new pb::MessageParser<TimeRange>(() => new TimeRange());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TimeRange> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::TransitRealtime.GtfsRealtimeReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TimeRange() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TimeRange(TimeRange other) : this() {
      start_ = other.start_;
      end_ = other.end_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TimeRange Clone() {
      return new TimeRange(this);
    }

    /// <summary>Field number for the "start" field.</summary>
    public const int StartFieldNumber = 1;
    private ulong start_;
    /// <summary>
    ///  Start time, in POSIX time (i.e., number of seconds since January 1st 1970
    ///  00:00:00 UTC).
    ///  If missing, the interval starts at minus infinity.
    ///  optional uint64 start = 1;
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong Start {
      get { return start_; }
      set {
        start_ = value;
      }
    }

    /// <summary>Field number for the "end" field.</summary>
    public const int EndFieldNumber = 2;
    private ulong end_;
    /// <summary>
    ///  End time, in POSIX time (i.e., number of seconds since January 1st 1970
    ///  00:00:00 UTC).
    ///  If missing, the interval ends at plus infinity.
    ///  optional uint64 end = 2;
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong End {
      get { return end_; }
      set {
        end_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TimeRange);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TimeRange other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Start != other.Start) return false;
      if (End != other.End) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Start != 0UL) hash ^= Start.GetHashCode();
      if (End != 0UL) hash ^= End.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Start != 0UL) {
        output.WriteRawTag(8);
        output.WriteUInt64(Start);
      }
      if (End != 0UL) {
        output.WriteRawTag(16);
        output.WriteUInt64(End);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Start != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(Start);
      }
      if (End != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(End);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TimeRange other) {
      if (other == null) {
        return;
      }
      if (other.Start != 0UL) {
        Start = other.Start;
      }
      if (other.End != 0UL) {
        End = other.End;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            Start = input.ReadUInt64();
            break;
          }
          case 16: {
            End = input.ReadUInt64();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///  A position.
  /// </summary>
  public sealed partial class Position : pb::IMessage<Position> {
    private static readonly pb::MessageParser<Position> _parser = new pb::MessageParser<Position>(() => new Position());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Position> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::TransitRealtime.GtfsRealtimeReflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Position() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Position(Position other) : this() {
      latitude_ = other.latitude_;
      longitude_ = other.longitude_;
      bearing_ = other.bearing_;
      odometer_ = other.odometer_;
      speed_ = other.speed_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Position Clone() {
      return new Position(this);
    }

    /// <summary>Field number for the "latitude" field.</summary>
    public const int LatitudeFieldNumber = 1;
    private float latitude_;
    /// <summary>
    ///  Degrees North, in the WGS-84 coordinate system.
    ///  required float latitude = 1;
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float Latitude {
      get { return latitude_; }
      set {
        latitude_ = value;
      }
    }

    /// <summary>Field number for the "longitude" field.</summary>
    public const int LongitudeFieldNumber = 2;
    private float longitude_;
    /// <summary>
    ///  Degrees East, in the WGS-84 coordinate system.
    ///  required float longitude = 2;
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float Longitude {
      get { return longitude_; }
      set {
        longitude_ = value;
      }
    }

    /// <summary>Field number for the "bearing" field.</summary>
    public const int BearingFieldNumber = 3;
    private float bearing_;
    /// <summary>
    ///  Bearing, in degrees, clockwise from North, i.e., 0 is North and 90 is East.
    ///  This can be the compass bearing, or the direction towards the next stop
    ///  or intermediate location.
    ///  This should not be direction deduced from the sequence of previous
    ///  positions, which can be computed from previous data.
    ///  optional float bearing = 3;
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float Bearing {
      get { return bearing_; }
      set {
        bearing_ = value;
      }
    }

    /// <summary>Field number for the "odometer" field.</summary>
    public const int OdometerFieldNumber = 4;
    private double odometer_;
    /// <summary>
    ///  Odometer value, in meters.
    ///  optional double odometer = 4;
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double Odometer {
      get { return odometer_; }
      set {
        odometer_ = value;
      }
    }

    /// <summary>Field number for the "speed" field.</summary>
    public const int SpeedFieldNumber = 5;
    private float speed_;
    /// <summary>
    ///  Momentary speed measured by the vehicle, in meters per second.
    ///  optional float speed = 5;
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float Speed {
      get { return speed_; }
      set {
        speed_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Position);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Position other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Latitude != other.Latitude) return false;
      if (Longitude != other.Longitude) return false;
      if (Bearing != other.Bearing) return false;
      if (Odometer != other.Odometer) return false;
      if (Speed != other.Speed) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Latitude != 0F) hash ^= Latitude.GetHashCode();
      if (Longitude != 0F) hash ^= Longitude.GetHashCode();
      if (Bearing != 0F) hash ^= Bearing.GetHashCode();
      if (Odometer != 0D) hash ^= Odometer.GetHashCode();
      if (Speed != 0F) hash ^= Speed.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Latitude != 0F) {
        output.WriteRawTag(13);
        output.WriteFloat(Latitude);
      }
      if (Longitude != 0F) {
        output.WriteRawTag(21);
        output.WriteFloat(Longitude);
      }
      if (Bearing != 0F) {
        output.WriteRawTag(29);
        output.WriteFloat(Bearing);
      }
      if (Odometer != 0D) {
        output.WriteRawTag(33);
        output.WriteDouble(Odometer);
      }
      if (Speed != 0F) {
        output.WriteRawTag(45);
        output.WriteFloat(Speed);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Latitude != 0F) {
        size += 1 + 4;
      }
      if (Longitude != 0F) {
        size += 1 + 4;
      }
      if (Bearing != 0F) {
        size += 1 + 4;
      }
      if (Odometer != 0D) {
        size += 1 + 8;
      }
      if (Speed != 0F) {
        size += 1 + 4;
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Position other) {
      if (other == null) {
        return;
      }
      if (other.Latitude != 0F) {
        Latitude = other.Latitude;
      }
      if (other.Longitude != 0F) {
        Longitude = other.Longitude;
      }
      if (other.Bearing != 0F) {
        Bearing = other.Bearing;
      }
      if (other.Odometer != 0D) {
        Odometer = other.Odometer;
      }
      if (other.Speed != 0F) {
        Speed = other.Speed;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 13: {
            Latitude = input.ReadFloat();
            break;
          }
          case 21: {
            Longitude = input.ReadFloat();
            break;
          }
          case 29: {
            Bearing = input.ReadFloat();
            break;
          }
          case 33: {
            Odometer = input.ReadDouble();
            break;
          }
          case 45: {
            Speed = input.ReadFloat();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///  A descriptor that identifies an instance of a GTFS trip, or all instances of
  ///  a trip along a route.
  ///  - To specify a single trip instance, the trip_id (and if necessary,
  ///    start_time) is set. If route_id is also set, then it should be same as one
  ///    that the given trip corresponds to.
  ///  - To specify all the trips along a given route, only the route_id should be
  ///    set. Note that if the trip_id is not known, then stop sequence ids in
  ///    TripUpdate are not sufficient, and stop_ids must be provided as well. In
  ///    addition, absolute arrival/departure times must be provided.
  /// </summary>
  public sealed partial class TripDescriptor : pb::IMessage<TripDescriptor> {
    private static readonly pb::MessageParser<TripDescriptor> _parser = new pb::MessageParser<TripDescriptor>(() => new TripDescriptor());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TripDescriptor> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::TransitRealtime.GtfsRealtimeReflection.Descriptor.MessageTypes[8]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TripDescriptor() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TripDescriptor(TripDescriptor other) : this() {
      tripId_ = other.tripId_;
      routeId_ = other.routeId_;
      directionId_ = other.directionId_;
      startTime_ = other.startTime_;
      startDate_ = other.startDate_;
      scheduleRelationship_ = other.scheduleRelationship_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TripDescriptor Clone() {
      return new TripDescriptor(this);
    }

    /// <summary>Field number for the "trip_id" field.</summary>
    public const int TripIdFieldNumber = 1;
    private string tripId_ = "";
    /// <summary>
    ///  The trip_id from the GTFS feed that this selector refers to.
    ///  For non frequency-based trips, this field is enough to uniquely identify
    ///  the trip. For frequency-based trip, start_time and start_date might also be
    ///  necessary.
    ///  optional string trip_id = 1;
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string TripId {
      get { return tripId_; }
      set {
        tripId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "route_id" field.</summary>
    public const int RouteIdFieldNumber = 5;
    private string routeId_ = "";
    /// <summary>
    ///  The route_id from the GTFS that this selector refers to.
    ///  optional string route_id = 5;
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string RouteId {
      get { return routeId_; }
      set {
        routeId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "direction_id" field.</summary>
    public const int DirectionIdFieldNumber = 6;
    private uint directionId_;
    /// <summary>
    ///  The direction_id from the GTFS feed trips.txt file, indicating the
    ///  direction of travel for trips this selector refers to. This field is
    ///  still experimental, and subject to change. It may be formally adopted in
    ///  the future.
    ///  optional uint32 direction_id = 6;
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint DirectionId {
      get { return directionId_; }
      set {
        directionId_ = value;
      }
    }

    /// <summary>Field number for the "start_time" field.</summary>
    public const int StartTimeFieldNumber = 2;
    private string startTime_ = "";
    /// <summary>
    ///  The initially scheduled start time of this trip instance.
    ///  When the trip_id corresponds to a non-frequency-based trip, this field
    ///  should either be omitted or be equal to the value in the GTFS feed. When
    ///  the trip_id correponds to a frequency-based trip, the start_time must be
    ///  specified for trip updates and vehicle positions. If the trip corresponds
    ///  to exact_times=1 GTFS record, then start_time must be some multiple
    ///  (including zero) of headway_secs later than frequencies.txt start_time for
    ///  the corresponding time period. If the trip corresponds to exact_times=0,
    ///  then its start_time may be arbitrary, and is initially expected to be the
    ///  first departure of the trip. Once established, the start_time of this
    ///  frequency-based trip should be considered immutable, even if the first
    ///  departure time changes -- that time change may instead be reflected in a
    ///  StopTimeUpdate.
    ///  Format and semantics of the field is same as that of
    ///  GTFS/frequencies.txt/start_time, e.g., 11:15:35 or 25:15:35.
    ///  optional string start_time = 2;
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string StartTime {
      get { return startTime_; }
      set {
        startTime_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "start_date" field.</summary>
    public const int StartDateFieldNumber = 3;
    private string startDate_ = "";
    /// <summary>
    ///  The scheduled start date of this trip instance.
    ///  Must be provided to disambiguate trips that are so late as to collide with
    ///  a scheduled trip on a next day. For example, for a train that departs 8:00
    ///  and 20:00 every day, and is 12 hours late, there would be two distinct
    ///  trips on the same time.
    ///  This field can be provided but is not mandatory for schedules in which such
    ///  collisions are impossible - for example, a service running on hourly
    ///  schedule where a vehicle that is one hour late is not considered to be
    ///  related to schedule anymore.
    ///  In YYYYMMDD format.
    ///  optional string start_date = 3;
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string StartDate {
      get { return startDate_; }
      set {
        startDate_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "schedule_relationship" field.</summary>
    public const int ScheduleRelationshipFieldNumber = 4;
    private global::TransitRealtime.TripDescriptor.Types.ScheduleRelationship scheduleRelationship_ = 0;
    /// <summary>
    ///  optional ScheduleRelationship schedule_relationship = 4;
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::TransitRealtime.TripDescriptor.Types.ScheduleRelationship ScheduleRelationship {
      get { return scheduleRelationship_; }
      set {
        scheduleRelationship_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TripDescriptor);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TripDescriptor other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (TripId != other.TripId) return false;
      if (RouteId != other.RouteId) return false;
      if (DirectionId != other.DirectionId) return false;
      if (StartTime != other.StartTime) return false;
      if (StartDate != other.StartDate) return false;
      if (ScheduleRelationship != other.ScheduleRelationship) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (TripId.Length != 0) hash ^= TripId.GetHashCode();
      if (RouteId.Length != 0) hash ^= RouteId.GetHashCode();
      if (DirectionId != 0) hash ^= DirectionId.GetHashCode();
      if (StartTime.Length != 0) hash ^= StartTime.GetHashCode();
      if (StartDate.Length != 0) hash ^= StartDate.GetHashCode();
      if (ScheduleRelationship != 0) hash ^= ScheduleRelationship.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (TripId.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(TripId);
      }
      if (StartTime.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(StartTime);
      }
      if (StartDate.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(StartDate);
      }
      if (ScheduleRelationship != 0) {
        output.WriteRawTag(32);
        output.WriteEnum((int) ScheduleRelationship);
      }
      if (RouteId.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(RouteId);
      }
      if (DirectionId != 0) {
        output.WriteRawTag(48);
        output.WriteUInt32(DirectionId);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (TripId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(TripId);
      }
      if (RouteId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(RouteId);
      }
      if (DirectionId != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(DirectionId);
      }
      if (StartTime.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(StartTime);
      }
      if (StartDate.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(StartDate);
      }
      if (ScheduleRelationship != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ScheduleRelationship);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TripDescriptor other) {
      if (other == null) {
        return;
      }
      if (other.TripId.Length != 0) {
        TripId = other.TripId;
      }
      if (other.RouteId.Length != 0) {
        RouteId = other.RouteId;
      }
      if (other.DirectionId != 0) {
        DirectionId = other.DirectionId;
      }
      if (other.StartTime.Length != 0) {
        StartTime = other.StartTime;
      }
      if (other.StartDate.Length != 0) {
        StartDate = other.StartDate;
      }
      if (other.ScheduleRelationship != 0) {
        ScheduleRelationship = other.ScheduleRelationship;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            TripId = input.ReadString();
            break;
          }
          case 18: {
            StartTime = input.ReadString();
            break;
          }
          case 26: {
            StartDate = input.ReadString();
            break;
          }
          case 32: {
            scheduleRelationship_ = (global::TransitRealtime.TripDescriptor.Types.ScheduleRelationship) input.ReadEnum();
            break;
          }
          case 42: {
            RouteId = input.ReadString();
            break;
          }
          case 48: {
            DirectionId = input.ReadUInt32();
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the TripDescriptor message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      ///  The relation between this trip and the static schedule. If a trip is done
      ///  in accordance with temporary schedule, not reflected in GTFS, then it
      ///  shouldn't be marked as SCHEDULED, but likely as ADDED.
      /// </summary>
      public enum ScheduleRelationship {
        /// <summary>
        ///  Trip that is running in accordance with its GTFS schedule, or is close
        ///  enough to the scheduled trip to be associated with it.
        /// </summary>
        [pbr::OriginalName("SCHEDULED")] Scheduled = 0,
        /// <summary>
        ///  An extra trip that was added in addition to a running schedule, for
        ///  example, to replace a broken vehicle or to respond to sudden passenger
        ///  load.
        /// </summary>
        [pbr::OriginalName("ADDED")] Added = 1,
        /// <summary>
        ///  A trip that is running with no schedule associated to it, for example, if
        ///  there is no schedule at all.
        /// </summary>
        [pbr::OriginalName("UNSCHEDULED")] Unscheduled = 2,
        /// <summary>
        ///  A trip that existed in the schedule but was removed.
        /// </summary>
        [pbr::OriginalName("CANCELED")] Canceled = 3,
      }

    }
    #endregion

  }

  /// <summary>
  ///  Identification information for the vehicle performing the trip.
  /// </summary>
  public sealed partial class VehicleDescriptor : pb::IMessage<VehicleDescriptor> {
    private static readonly pb::MessageParser<VehicleDescriptor> _parser = new pb::MessageParser<VehicleDescriptor>(() => new VehicleDescriptor());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<VehicleDescriptor> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::TransitRealtime.GtfsRealtimeReflection.Descriptor.MessageTypes[9]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public VehicleDescriptor() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public VehicleDescriptor(VehicleDescriptor other) : this() {
      id_ = other.id_;
      label_ = other.label_;
      licensePlate_ = other.licensePlate_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public VehicleDescriptor Clone() {
      return new VehicleDescriptor(this);
    }

    /// <summary>Field number for the "id" field.</summary>
    public const int IdFieldNumber = 1;
    private string id_ = "";
    /// <summary>
    ///  Internal system identification of the vehicle. Should be unique per
    ///  vehicle, and can be used for tracking the vehicle as it proceeds through
    ///  the system.
    ///  optional string id = 1;
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Id {
      get { return id_; }
      set {
        id_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "label" field.</summary>
    public const int LabelFieldNumber = 2;
    private string label_ = "";
    /// <summary>
    ///  User visible label, i.e., something that must be shown to the passenger to
    ///  help identify the correct vehicle.
    ///  optional string label = 2;
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Label {
      get { return label_; }
      set {
        label_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "license_plate" field.</summary>
    public const int LicensePlateFieldNumber = 3;
    private string licensePlate_ = "";
    /// <summary>
    ///  The license plate of the vehicle.
    ///  optional string license_plate = 3;
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string LicensePlate {
      get { return licensePlate_; }
      set {
        licensePlate_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as VehicleDescriptor);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(VehicleDescriptor other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Id != other.Id) return false;
      if (Label != other.Label) return false;
      if (LicensePlate != other.LicensePlate) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Id.Length != 0) hash ^= Id.GetHashCode();
      if (Label.Length != 0) hash ^= Label.GetHashCode();
      if (LicensePlate.Length != 0) hash ^= LicensePlate.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Id.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Id);
      }
      if (Label.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Label);
      }
      if (LicensePlate.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(LicensePlate);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Id.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Id);
      }
      if (Label.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Label);
      }
      if (LicensePlate.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(LicensePlate);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(VehicleDescriptor other) {
      if (other == null) {
        return;
      }
      if (other.Id.Length != 0) {
        Id = other.Id;
      }
      if (other.Label.Length != 0) {
        Label = other.Label;
      }
      if (other.LicensePlate.Length != 0) {
        LicensePlate = other.LicensePlate;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            Id = input.ReadString();
            break;
          }
          case 18: {
            Label = input.ReadString();
            break;
          }
          case 26: {
            LicensePlate = input.ReadString();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///  A selector for an entity in a GTFS feed.
  /// </summary>
  public sealed partial class EntitySelector : pb::IMessage<EntitySelector> {
    private static readonly pb::MessageParser<EntitySelector> _parser = new pb::MessageParser<EntitySelector>(() => new EntitySelector());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<EntitySelector> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::TransitRealtime.GtfsRealtimeReflection.Descriptor.MessageTypes[10]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public EntitySelector() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public EntitySelector(EntitySelector other) : this() {
      agencyId_ = other.agencyId_;
      routeId_ = other.routeId_;
      routeType_ = other.routeType_;
      Trip = other.trip_ != null ? other.Trip.Clone() : null;
      stopId_ = other.stopId_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public EntitySelector Clone() {
      return new EntitySelector(this);
    }

    /// <summary>Field number for the "agency_id" field.</summary>
    public const int AgencyIdFieldNumber = 1;
    private string agencyId_ = "";
    /// <summary>
    ///  The values of the fields should correspond to the appropriate fields in the
    ///  GTFS feed.
    ///  At least one specifier must be given. If several are given, then the
    ///  matching has to apply to all the given specifiers.
    ///  optional string agency_id = 1;
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string AgencyId {
      get { return agencyId_; }
      set {
        agencyId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "route_id" field.</summary>
    public const int RouteIdFieldNumber = 2;
    private string routeId_ = "";
    /// <summary>
    ///  optional string route_id = 2;
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string RouteId {
      get { return routeId_; }
      set {
        routeId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "route_type" field.</summary>
    public const int RouteTypeFieldNumber = 3;
    private int routeType_;
    /// <summary>
    ///  corresponds to route_type in GTFS.
    ///  optional int32 route_type = 3;
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int RouteType {
      get { return routeType_; }
      set {
        routeType_ = value;
      }
    }

    /// <summary>Field number for the "trip" field.</summary>
    public const int TripFieldNumber = 4;
    private global::TransitRealtime.TripDescriptor trip_;
    /// <summary>
    ///  optional TripDescriptor trip = 4;
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::TransitRealtime.TripDescriptor Trip {
      get { return trip_; }
      set {
        trip_ = value;
      }
    }

    /// <summary>Field number for the "stop_id" field.</summary>
    public const int StopIdFieldNumber = 5;
    private string stopId_ = "";
    /// <summary>
    ///  optional string stop_id = 5;
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string StopId {
      get { return stopId_; }
      set {
        stopId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as EntitySelector);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(EntitySelector other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (AgencyId != other.AgencyId) return false;
      if (RouteId != other.RouteId) return false;
      if (RouteType != other.RouteType) return false;
      if (!object.Equals(Trip, other.Trip)) return false;
      if (StopId != other.StopId) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (AgencyId.Length != 0) hash ^= AgencyId.GetHashCode();
      if (RouteId.Length != 0) hash ^= RouteId.GetHashCode();
      if (RouteType != 0) hash ^= RouteType.GetHashCode();
      if (trip_ != null) hash ^= Trip.GetHashCode();
      if (StopId.Length != 0) hash ^= StopId.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (AgencyId.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(AgencyId);
      }
      if (RouteId.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(RouteId);
      }
      if (RouteType != 0) {
        output.WriteRawTag(24);
        output.WriteInt32(RouteType);
      }
      if (trip_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Trip);
      }
      if (StopId.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(StopId);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (AgencyId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(AgencyId);
      }
      if (RouteId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(RouteId);
      }
      if (RouteType != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(RouteType);
      }
      if (trip_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Trip);
      }
      if (StopId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(StopId);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(EntitySelector other) {
      if (other == null) {
        return;
      }
      if (other.AgencyId.Length != 0) {
        AgencyId = other.AgencyId;
      }
      if (other.RouteId.Length != 0) {
        RouteId = other.RouteId;
      }
      if (other.RouteType != 0) {
        RouteType = other.RouteType;
      }
      if (other.trip_ != null) {
        if (trip_ == null) {
          trip_ = new global::TransitRealtime.TripDescriptor();
        }
        Trip.MergeFrom(other.Trip);
      }
      if (other.StopId.Length != 0) {
        StopId = other.StopId;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            AgencyId = input.ReadString();
            break;
          }
          case 18: {
            RouteId = input.ReadString();
            break;
          }
          case 24: {
            RouteType = input.ReadInt32();
            break;
          }
          case 34: {
            if (trip_ == null) {
              trip_ = new global::TransitRealtime.TripDescriptor();
            }
            input.ReadMessage(trip_);
            break;
          }
          case 42: {
            StopId = input.ReadString();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///  An internationalized message containing per-language versions of a snippet of
  ///  text or a URL.
  ///  One of the strings from a message will be picked up. The resolution proceeds
  ///  as follows:
  ///  1. If the UI language matches the language code of a translation,
  ///     the first matching translation is picked.
  ///  2. If a default UI language (e.g., English) matches the language code of a
  ///     translation, the first matching translation is picked.
  ///  3. If some translation has an unspecified language code, that translation is
  ///     picked.
  /// </summary>
  public sealed partial class TranslatedString : pb::IMessage<TranslatedString> {
    private static readonly pb::MessageParser<TranslatedString> _parser = new pb::MessageParser<TranslatedString>(() => new TranslatedString());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TranslatedString> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::TransitRealtime.GtfsRealtimeReflection.Descriptor.MessageTypes[11]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TranslatedString() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TranslatedString(TranslatedString other) : this() {
      translation_ = other.translation_.Clone();
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TranslatedString Clone() {
      return new TranslatedString(this);
    }

    /// <summary>Field number for the "translation" field.</summary>
    public const int TranslationFieldNumber = 1;
    private static readonly pb::FieldCodec<global::TransitRealtime.TranslatedString.Types.Translation> _repeated_translation_codec
        = pb::FieldCodec.ForMessage(10, global::TransitRealtime.TranslatedString.Types.Translation.Parser);
    private readonly pbc::RepeatedField<global::TransitRealtime.TranslatedString.Types.Translation> translation_ = new pbc::RepeatedField<global::TransitRealtime.TranslatedString.Types.Translation>();
    /// <summary>
    ///  At least one translation must be provided.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::TransitRealtime.TranslatedString.Types.Translation> Translation {
      get { return translation_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TranslatedString);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TranslatedString other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!translation_.Equals(other.translation_)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= translation_.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      translation_.WriteTo(output, _repeated_translation_codec);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += translation_.CalculateSize(_repeated_translation_codec);
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TranslatedString other) {
      if (other == null) {
        return;
      }
      translation_.Add(other.translation_);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            translation_.AddEntriesFrom(input, _repeated_translation_codec);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the TranslatedString message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public sealed partial class Translation : pb::IMessage<Translation> {
        private static readonly pb::MessageParser<Translation> _parser = new pb::MessageParser<Translation>(() => new Translation());
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Translation> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::TransitRealtime.TranslatedString.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Translation() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Translation(Translation other) : this() {
          text_ = other.text_;
          language_ = other.language_;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Translation Clone() {
          return new Translation(this);
        }

        /// <summary>Field number for the "text" field.</summary>
        public const int TextFieldNumber = 1;
        private string text_ = "";
        /// <summary>
        ///  A UTF-8 string containing the message.
        ///  required string text = 1;
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Text {
          get { return text_; }
          set {
            text_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "language" field.</summary>
        public const int LanguageFieldNumber = 2;
        private string language_ = "";
        /// <summary>
        ///  BCP-47 language code. Can be omitted if the language is unknown or if
        ///  no i18n is done at all for the feed. At most one translation is
        ///  allowed to have an unspecified language tag.
        ///  optional string language = 2;
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Language {
          get { return language_; }
          set {
            language_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Translation);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Translation other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Text != other.Text) return false;
          if (Language != other.Language) return false;
          return true;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Text.Length != 0) hash ^= Text.GetHashCode();
          if (Language.Length != 0) hash ^= Language.GetHashCode();
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (Text.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Text);
          }
          if (Language.Length != 0) {
            output.WriteRawTag(18);
            output.WriteString(Language);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Text.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Text);
          }
          if (Language.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Language);
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Translation other) {
          if (other == null) {
            return;
          }
          if (other.Text.Length != 0) {
            Text = other.Text;
          }
          if (other.Language.Length != 0) {
            Language = other.Language;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 10: {
                Text = input.ReadString();
                break;
              }
              case 18: {
                Language = input.ReadString();
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code
